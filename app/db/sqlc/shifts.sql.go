// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: shifts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAppointmentsByDoctorAndDate = `-- name: CountAppointmentsByDoctorAndDate :one
SELECT COUNT(*) as count
FROM appointments
WHERE doctor_id = $1 AND date >= $2 AND date < $3
`

type CountAppointmentsByDoctorAndDateParams struct {
	DoctorID pgtype.Int8      `json:"doctor_id"`
	Date     pgtype.Timestamp `json:"date"`
	Date_2   pgtype.Timestamp `json:"date_2"`
}

func (q *Queries) CountAppointmentsByDoctorAndDate(ctx context.Context, arg CountAppointmentsByDoctorAndDateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppointmentsByDoctorAndDate, arg.DoctorID, arg.Date, arg.Date_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countShiftsByDoctorAndDate = `-- name: CountShiftsByDoctorAndDate :one
SELECT COUNT(*) as count
FROM shifts
WHERE doctor_id = $1 AND start_time >= $2 AND end_time <= $3
`

type CountShiftsByDoctorAndDateParams struct {
	DoctorID  int64            `json:"doctor_id"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) CountShiftsByDoctorAndDate(ctx context.Context, arg CountShiftsByDoctorAndDateParams) (int64, error) {
	row := q.db.QueryRow(ctx, countShiftsByDoctorAndDate, arg.DoctorID, arg.StartTime, arg.EndTime)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createShift = `-- name: CreateShift :one
INSERT INTO shifts (doctor_id, start_time, end_time, assigned_patients)
VALUES ($1, $2, $3, $4)
RETURNING id, doctor_id, start_time, end_time, assigned_patients, created_at
`

type CreateShiftParams struct {
	DoctorID         int64            `json:"doctor_id"`
	StartTime        pgtype.Timestamp `json:"start_time"`
	EndTime          pgtype.Timestamp `json:"end_time"`
	AssignedPatients pgtype.Int4      `json:"assigned_patients"`
}

type CreateShiftRow struct {
	ID               int64            `json:"id"`
	DoctorID         int64            `json:"doctor_id"`
	StartTime        pgtype.Timestamp `json:"start_time"`
	EndTime          pgtype.Timestamp `json:"end_time"`
	AssignedPatients pgtype.Int4      `json:"assigned_patients"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateShift(ctx context.Context, arg CreateShiftParams) (CreateShiftRow, error) {
	row := q.db.QueryRow(ctx, createShift,
		arg.DoctorID,
		arg.StartTime,
		arg.EndTime,
		arg.AssignedPatients,
	)
	var i CreateShiftRow
	err := row.Scan(
		&i.ID,
		&i.DoctorID,
		&i.StartTime,
		&i.EndTime,
		&i.AssignedPatients,
		&i.CreatedAt,
	)
	return i, err
}

const deleteShiftsByDate = `-- name: DeleteShiftsByDate :exec
DELETE FROM shifts
WHERE start_time >= $1 AND end_time <= $2
`

type DeleteShiftsByDateParams struct {
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) DeleteShiftsByDate(ctx context.Context, arg DeleteShiftsByDateParams) error {
	_, err := q.db.Exec(ctx, deleteShiftsByDate, arg.StartTime, arg.EndTime)
	return err
}

const getAppointmentsByTimeSlot = `-- name: GetAppointmentsByTimeSlot :many
SELECT a.appointment_id, a.doctor_id, a.time_slot_id, a.service_id, s.category
FROM appointments a
JOIN services s ON a.service_id = s.id
WHERE a.time_slot_id = $1
`

type GetAppointmentsByTimeSlotRow struct {
	AppointmentID int64       `json:"appointment_id"`
	DoctorID      pgtype.Int8 `json:"doctor_id"`
	TimeSlotID    pgtype.Int8 `json:"time_slot_id"`
	ServiceID     pgtype.Int8 `json:"service_id"`
	Category      pgtype.Text `json:"category"`
}

func (q *Queries) GetAppointmentsByTimeSlot(ctx context.Context, timeSlotID pgtype.Int8) ([]GetAppointmentsByTimeSlotRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentsByTimeSlot, timeSlotID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAppointmentsByTimeSlotRow{}
	for rows.Next() {
		var i GetAppointmentsByTimeSlotRow
		if err := rows.Scan(
			&i.AppointmentID,
			&i.DoctorID,
			&i.TimeSlotID,
			&i.ServiceID,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoctors = `-- name: GetDoctors :many
SELECT id, specialization
FROM doctors
`

type GetDoctorsRow struct {
	ID             int64       `json:"id"`
	Specialization pgtype.Text `json:"specialization"`
}

func (q *Queries) GetDoctors(ctx context.Context) ([]GetDoctorsRow, error) {
	rows, err := q.db.Query(ctx, getDoctors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDoctorsRow{}
	for rows.Next() {
		var i GetDoctorsRow
		if err := rows.Scan(&i.ID, &i.Specialization); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShifts = `-- name: GetShifts :many
SELECT id, doctor_id, start_time, end_time, assigned_patients, created_at
FROM shifts
ORDER BY start_time
`

type GetShiftsRow struct {
	ID               int64            `json:"id"`
	DoctorID         int64            `json:"doctor_id"`
	StartTime        pgtype.Timestamp `json:"start_time"`
	EndTime          pgtype.Timestamp `json:"end_time"`
	AssignedPatients pgtype.Int4      `json:"assigned_patients"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetShifts(ctx context.Context) ([]GetShiftsRow, error) {
	rows, err := q.db.Query(ctx, getShifts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetShiftsRow{}
	for rows.Next() {
		var i GetShiftsRow
		if err := rows.Scan(
			&i.ID,
			&i.DoctorID,
			&i.StartTime,
			&i.EndTime,
			&i.AssignedPatients,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSlotsByDoctorAndDate = `-- name: GetTimeSlotsByDoctorAndDate :many
SELECT id, doctor_id, date, start_time, end_time, max_patients, booked_patients
FROM time_slots
WHERE doctor_id = $1 AND date = $2
`

type GetTimeSlotsByDoctorAndDateParams struct {
	DoctorID int32       `json:"doctor_id"`
	Date     pgtype.Date `json:"date"`
}

type GetTimeSlotsByDoctorAndDateRow struct {
	ID             int64       `json:"id"`
	DoctorID       int32       `json:"doctor_id"`
	Date           pgtype.Date `json:"date"`
	StartTime      pgtype.Time `json:"start_time"`
	EndTime        pgtype.Time `json:"end_time"`
	MaxPatients    pgtype.Int4 `json:"max_patients"`
	BookedPatients pgtype.Int4 `json:"booked_patients"`
}

func (q *Queries) GetTimeSlotsByDoctorAndDate(ctx context.Context, arg GetTimeSlotsByDoctorAndDateParams) ([]GetTimeSlotsByDoctorAndDateRow, error) {
	rows, err := q.db.Query(ctx, getTimeSlotsByDoctorAndDate, arg.DoctorID, arg.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTimeSlotsByDoctorAndDateRow{}
	for rows.Next() {
		var i GetTimeSlotsByDoctorAndDateRow
		if err := rows.Scan(
			&i.ID,
			&i.DoctorID,
			&i.Date,
			&i.StartTime,
			&i.EndTime,
			&i.MaxPatients,
			&i.BookedPatients,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
