// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: treatment.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignCarprofenToInitialPhase = `-- name: AssignCarprofenToInitialPhase :exec
INSERT INTO phase_medicines (phase_id, medicine_id, dosage, frequency, duration, notes)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING phase_id, medicine_id, dosage, frequency, duration, notes, created_at
`

type AssignCarprofenToInitialPhaseParams struct {
	PhaseID    int64       `json:"phase_id"`
	MedicineID int64       `json:"medicine_id"`
	Dosage     pgtype.Text `json:"dosage"`
	Frequency  pgtype.Text `json:"frequency"`
	Duration   pgtype.Text `json:"duration"`
	Notes      pgtype.Text `json:"notes"`
}

// Assign Carprofen to the Initial Phase
func (q *Queries) AssignCarprofenToInitialPhase(ctx context.Context, arg AssignCarprofenToInitialPhaseParams) error {
	_, err := q.db.Exec(ctx, assignCarprofenToInitialPhase,
		arg.PhaseID,
		arg.MedicineID,
		arg.Dosage,
		arg.Frequency,
		arg.Duration,
		arg.Notes,
	)
	return err
}

const assignMedicationToTreatmentPhase = `-- name: AssignMedicationToTreatmentPhase :one
INSERT INTO phase_medicines (phase_id, medicine_id, dosage, frequency, duration, notes, created_at)
VALUES ($1, $2, $3, $4, $5, $6, now()) RETURNING phase_id, medicine_id, dosage, frequency, duration, notes, created_at
`

type AssignMedicationToTreatmentPhaseParams struct {
	PhaseID    int64       `json:"phase_id"`
	MedicineID int64       `json:"medicine_id"`
	Dosage     pgtype.Text `json:"dosage"`
	Frequency  pgtype.Text `json:"frequency"`
	Duration   pgtype.Text `json:"duration"`
	Notes      pgtype.Text `json:"notes"`
}

func (q *Queries) AssignMedicationToTreatmentPhase(ctx context.Context, arg AssignMedicationToTreatmentPhaseParams) (PhaseMedicine, error) {
	row := q.db.QueryRow(ctx, assignMedicationToTreatmentPhase,
		arg.PhaseID,
		arg.MedicineID,
		arg.Dosage,
		arg.Frequency,
		arg.Duration,
		arg.Notes,
	)
	var i PhaseMedicine
	err := row.Scan(
		&i.PhaseID,
		&i.MedicineID,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createTreatment = `-- name: CreateTreatment :one
INSERT INTO pet_treatments (pet_id, disease_id, start_date, end_date, status, notes, created_at)
VALUES ($1, $2, $3, $4, $5, $6, now()) RETURNING id, pet_id, disease_id, start_date, end_date, status, notes, created_at
`

type CreateTreatmentParams struct {
	PetID     pgtype.Int8 `json:"pet_id"`
	DiseaseID pgtype.Int8 `json:"disease_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Status    pgtype.Text `json:"status"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) CreateTreatment(ctx context.Context, arg CreateTreatmentParams) (PetTreatment, error) {
	row := q.db.QueryRow(ctx, createTreatment,
		arg.PetID,
		arg.DiseaseID,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.Notes,
	)
	var i PetTreatment
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.DiseaseID,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const createTreatmentPhase = `-- name: CreateTreatmentPhase :one
INSERT INTO treatment_phases (treatment_id, phase_name, description, start_date, status, created_at)
VALUES ($1, $2, $3, $4, $5, now()) RETURNING id, treatment_id, phase_name, description, status, start_date, created_at
`

type CreateTreatmentPhaseParams struct {
	TreatmentID pgtype.Int8 `json:"treatment_id"`
	PhaseName   pgtype.Text `json:"phase_name"`
	Description pgtype.Text `json:"description"`
	StartDate   pgtype.Date `json:"start_date"`
	Status      pgtype.Text `json:"status"`
}

func (q *Queries) CreateTreatmentPhase(ctx context.Context, arg CreateTreatmentPhaseParams) (TreatmentPhase, error) {
	row := q.db.QueryRow(ctx, createTreatmentPhase,
		arg.TreatmentID,
		arg.PhaseName,
		arg.Description,
		arg.StartDate,
		arg.Status,
	)
	var i TreatmentPhase
	err := row.Scan(
		&i.ID,
		&i.TreatmentID,
		&i.PhaseName,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTreatment = `-- name: DeleteTreatment :exec
DELETE FROM pet_treatments
WHERE id = $1
`

func (q *Queries) DeleteTreatment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTreatment, id)
	return err
}

const deleteTreatmentPhase = `-- name: DeleteTreatmentPhase :exec
DELETE FROM treatment_phases
WHERE id = $1
`

func (q *Queries) DeleteTreatmentPhase(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTreatmentPhase, id)
	return err
}

const getActiveTreatments = `-- name: GetActiveTreatments :many
SELECT t.id, p.name AS pet_name, d.name AS disease, t.start_date, t.end_date, t.status
FROM pet_treatments t
JOIN pet p ON t.pet_id = p.petid
JOIN diseases d ON t.disease_id = d.id
WHERE t.status = 'ongoing' AND p.petid
`

type GetActiveTreatmentsRow struct {
	ID        int64       `json:"id"`
	PetName   string      `json:"pet_name"`
	Disease   string      `json:"disease"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Status    pgtype.Text `json:"status"`
}

// Get All Active Treatments
func (q *Queries) GetActiveTreatments(ctx context.Context) ([]GetActiveTreatmentsRow, error) {
	rows, err := q.db.Query(ctx, getActiveTreatments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveTreatmentsRow{}
	for rows.Next() {
		var i GetActiveTreatmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PetName,
			&i.Disease,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedicationsByPhase = `-- name: GetMedicationsByPhase :many
SELECT m.id, m.name, pm.dosage, pm.frequency, pm.duration, pm.notes
FROM medicines m
JOIN phase_medicines pm ON m.id = pm.medicine_id
WHERE pm.phase_id = $1
`

type GetMedicationsByPhaseRow struct {
	ID        int64       `json:"id"`
	Name      string      `json:"name"`
	Dosage    pgtype.Text `json:"dosage"`
	Frequency pgtype.Text `json:"frequency"`
	Duration  pgtype.Text `json:"duration"`
	Notes     pgtype.Text `json:"notes"`
}

// Get Medications for a Treatment Phase
func (q *Queries) GetMedicationsByPhase(ctx context.Context, phaseID int64) ([]GetMedicationsByPhaseRow, error) {
	rows, err := q.db.Query(ctx, getMedicationsByPhase, phaseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMedicationsByPhaseRow{}
	for rows.Next() {
		var i GetMedicationsByPhaseRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Dosage,
			&i.Frequency,
			&i.Duration,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreatment = `-- name: GetTreatment :one
SELECT id, pet_id, disease_id, start_date, end_date, status, notes, created_at FROM pet_treatments
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTreatment(ctx context.Context, id int64) (PetTreatment, error) {
	row := q.db.QueryRow(ctx, getTreatment, id)
	var i PetTreatment
	err := row.Scan(
		&i.ID,
		&i.PetID,
		&i.DiseaseID,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getTreatmentPhase = `-- name: GetTreatmentPhase :one
SELECT id, treatment_id, phase_name, description, status, start_date, created_at FROM treatment_phases
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTreatmentPhase(ctx context.Context, id int64) (TreatmentPhase, error) {
	row := q.db.QueryRow(ctx, getTreatmentPhase, id)
	var i TreatmentPhase
	err := row.Scan(
		&i.ID,
		&i.TreatmentID,
		&i.PhaseName,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.CreatedAt,
	)
	return i, err
}

const getTreatmentPhasesByTreatment = `-- name: GetTreatmentPhasesByTreatment :many
SELECT tp.id, treatment_id, phase_name, description, tp.status, tp.start_date, tp.created_at, t.id, pet_id, disease_id, t.start_date, end_date, t.status, notes, t.created_at  FROM treatment_phases as tp
JOIN pet_treatments t ON t.id = tp.treatment_id
WHERE t.id = $1 LIMIT $2 OFFSET $3
`

type GetTreatmentPhasesByTreatmentParams struct {
	ID     int64 `json:"id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetTreatmentPhasesByTreatmentRow struct {
	ID          int64              `json:"id"`
	TreatmentID pgtype.Int8        `json:"treatment_id"`
	PhaseName   pgtype.Text        `json:"phase_name"`
	Description pgtype.Text        `json:"description"`
	Status      pgtype.Text        `json:"status"`
	StartDate   pgtype.Date        `json:"start_date"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	ID_2        int64              `json:"id_2"`
	PetID       pgtype.Int8        `json:"pet_id"`
	DiseaseID   pgtype.Int8        `json:"disease_id"`
	StartDate_2 pgtype.Date        `json:"start_date_2"`
	EndDate     pgtype.Date        `json:"end_date"`
	Status_2    pgtype.Text        `json:"status_2"`
	Notes       pgtype.Text        `json:"notes"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

// Get Treatment Phases for a Treatment
func (q *Queries) GetTreatmentPhasesByTreatment(ctx context.Context, arg GetTreatmentPhasesByTreatmentParams) ([]GetTreatmentPhasesByTreatmentRow, error) {
	rows, err := q.db.Query(ctx, getTreatmentPhasesByTreatment, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreatmentPhasesByTreatmentRow{}
	for rows.Next() {
		var i GetTreatmentPhasesByTreatmentRow
		if err := rows.Scan(
			&i.ID,
			&i.TreatmentID,
			&i.PhaseName,
			&i.Description,
			&i.Status,
			&i.StartDate,
			&i.CreatedAt,
			&i.ID_2,
			&i.PetID,
			&i.DiseaseID,
			&i.StartDate_2,
			&i.EndDate,
			&i.Status_2,
			&i.Notes,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreatmentProgress = `-- name: GetTreatmentProgress :many
SELECT tp.phase_name, tp.status, tp.start_date,COUNT(pm.medicine_id) AS num_medicines
FROM treatment_phases tp
LEFT JOIN phase_medicines pm ON tp.id = pm.phase_id
WHERE tp.id = $1
GROUP BY tp.id
`

type GetTreatmentProgressRow struct {
	PhaseName    pgtype.Text `json:"phase_name"`
	Status       pgtype.Text `json:"status"`
	StartDate    pgtype.Date `json:"start_date"`
	NumMedicines int64       `json:"num_medicines"`
}

// Get Treatment Progress
func (q *Queries) GetTreatmentProgress(ctx context.Context, id int64) ([]GetTreatmentProgressRow, error) {
	rows, err := q.db.Query(ctx, getTreatmentProgress, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreatmentProgressRow{}
	for rows.Next() {
		var i GetTreatmentProgressRow
		if err := rows.Scan(
			&i.PhaseName,
			&i.Status,
			&i.StartDate,
			&i.NumMedicines,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTreatmentsByPet = `-- name: GetTreatmentsByPet :many
SELECT t.id as treatment_id, d.name AS disease, t.start_date, t.end_date, t.status
FROM pet_treatments t
JOIN diseases d ON t.disease_id = d.id
WHERE t.pet_id = $1 LIMIT $2 OFFSET $3
`

type GetTreatmentsByPetParams struct {
	PetID  pgtype.Int8 `json:"pet_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type GetTreatmentsByPetRow struct {
	TreatmentID int64       `json:"treatment_id"`
	Disease     string      `json:"disease"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	Status      pgtype.Text `json:"status"`
}

// Get All Treatments for a Pet
func (q *Queries) GetTreatmentsByPet(ctx context.Context, arg GetTreatmentsByPetParams) ([]GetTreatmentsByPetRow, error) {
	rows, err := q.db.Query(ctx, getTreatmentsByPet, arg.PetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTreatmentsByPetRow{}
	for rows.Next() {
		var i GetTreatmentsByPetRow
		if err := rows.Scan(
			&i.TreatmentID,
			&i.Disease,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTreatmentsByPet = `-- name: ListTreatmentsByPet :many
SELECT id, pet_id, disease_id, start_date, end_date, status, notes, created_at FROM pet_treatments
WHERE pet_id = $1
ORDER BY start_date DESC
LIMIT $2 OFFSET $3
`

type ListTreatmentsByPetParams struct {
	PetID  pgtype.Int8 `json:"pet_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListTreatmentsByPet(ctx context.Context, arg ListTreatmentsByPetParams) ([]PetTreatment, error) {
	rows, err := q.db.Query(ctx, listTreatmentsByPet, arg.PetID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PetTreatment{}
	for rows.Next() {
		var i PetTreatment
		if err := rows.Scan(
			&i.ID,
			&i.PetID,
			&i.DiseaseID,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTreatment = `-- name: UpdateTreatment :exec
UPDATE pet_treatments
SET disease_id = $2, start_date = $3, end_date = $4, status = $5, notes = $6
WHERE id = $1
`

type UpdateTreatmentParams struct {
	ID        int64       `json:"id"`
	DiseaseID pgtype.Int8 `json:"disease_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Status    pgtype.Text `json:"status"`
	Notes     pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateTreatment(ctx context.Context, arg UpdateTreatmentParams) error {
	_, err := q.db.Exec(ctx, updateTreatment,
		arg.ID,
		arg.DiseaseID,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
		arg.Notes,
	)
	return err
}

const updateTreatmentPhaseStatus = `-- name: UpdateTreatmentPhaseStatus :exec
UPDATE treatment_phases
SET status = $2 and updated_at = now()
WHERE id = $1
`

type UpdateTreatmentPhaseStatusParams struct {
	ID     int64       `json:"id"`
	Status pgtype.Text `json:"status"`
}

// Update Treatment Phase Status
func (q *Queries) UpdateTreatmentPhaseStatus(ctx context.Context, arg UpdateTreatmentPhaseStatusParams) error {
	_, err := q.db.Exec(ctx, updateTreatmentPhaseStatus, arg.ID, arg.Status)
	return err
}
