// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: appointment_statistics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAppointmentConfirmationStats = `-- name: GetAppointmentConfirmationStats :one
SELECT 
    COUNT(*) as total_appointments,
    COUNT(CASE WHEN s.state = 'Confirmed' THEN 1 END) as confirmed_count,
    COUNT(CASE WHEN s.state = 'Closed' THEN 1 END) as cancelled_count,
    ROUND(COUNT(CASE WHEN s.state = 'Confirmed' THEN 1 END)::numeric / COUNT(*)::numeric * 100, 2) as confirmation_rate,
    ROUND(COUNT(CASE WHEN s.state = 'Closed' THEN 1 END)::numeric / COUNT(*)::numeric * 100, 2) as cancellation_rate
FROM appointments a
JOIN states s ON a.state_id = s.id
WHERE date BETWEEN $1::timestamp AND $2::timestamp
`

type GetAppointmentConfirmationStatsParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

type GetAppointmentConfirmationStatsRow struct {
	TotalAppointments int64          `json:"total_appointments"`
	ConfirmedCount    int64          `json:"confirmed_count"`
	CancelledCount    int64          `json:"cancelled_count"`
	ConfirmationRate  pgtype.Numeric `json:"confirmation_rate"`
	CancellationRate  pgtype.Numeric `json:"cancellation_rate"`
}

// Tính tỷ lệ xác nhận và hủy lịch hẹn
func (q *Queries) GetAppointmentConfirmationStats(ctx context.Context, arg GetAppointmentConfirmationStatsParams) (GetAppointmentConfirmationStatsRow, error) {
	row := q.db.QueryRow(ctx, getAppointmentConfirmationStats, arg.StartDate, arg.EndDate)
	var i GetAppointmentConfirmationStatsRow
	err := row.Scan(
		&i.TotalAppointments,
		&i.ConfirmedCount,
		&i.CancelledCount,
		&i.ConfirmationRate,
		&i.CancellationRate,
	)
	return i, err
}

const getAppointmentCountByDateRange = `-- name: GetAppointmentCountByDateRange :many
SELECT 
    DATE(date) as appointment_date,
    COUNT(*) as appointment_count
FROM appointments
WHERE date BETWEEN $1::timestamp AND $2::timestamp
GROUP BY DATE(date)
ORDER BY appointment_date
`

type GetAppointmentCountByDateRangeParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

type GetAppointmentCountByDateRangeRow struct {
	AppointmentDate  pgtype.Date `json:"appointment_date"`
	AppointmentCount int64       `json:"appointment_count"`
}

// Đếm số lượng lịch hẹn theo từng ngày trong khoảng thời gian
func (q *Queries) GetAppointmentCountByDateRange(ctx context.Context, arg GetAppointmentCountByDateRangeParams) ([]GetAppointmentCountByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentCountByDateRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAppointmentCountByDateRangeRow{}
	for rows.Next() {
		var i GetAppointmentCountByDateRangeRow
		if err := rows.Scan(&i.AppointmentDate, &i.AppointmentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppointmentTrendsByHour = `-- name: GetAppointmentTrendsByHour :many
SELECT 
    EXTRACT(HOUR FROM date) as hour,
    COUNT(*) as appointment_count
FROM appointments
WHERE 
    date BETWEEN $1::timestamp AND $2::timestamp
GROUP BY EXTRACT(HOUR FROM date)
ORDER BY hour
`

type GetAppointmentTrendsByHourParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

type GetAppointmentTrendsByHourRow struct {
	Hour             pgtype.Numeric `json:"hour"`
	AppointmentCount int64          `json:"appointment_count"`
}

// Đếm số lượng lịch hẹn theo từng giờ trong ngày
func (q *Queries) GetAppointmentTrendsByHour(ctx context.Context, arg GetAppointmentTrendsByHourParams) ([]GetAppointmentTrendsByHourRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentTrendsByHour, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAppointmentTrendsByHourRow{}
	for rows.Next() {
		var i GetAppointmentTrendsByHourRow
		if err := rows.Scan(&i.Hour, &i.AppointmentCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppointmentsByStatus = `-- name: GetAppointmentsByStatus :many
SELECT 
    s.state,
    COUNT(*) as count
FROM appointments a
JOIN states s ON a.state_id = s.id
WHERE 
    CASE 
        WHEN $1::text = 'day' THEN DATE(a.date) = CURRENT_DATE
        WHEN $1::text = 'week' THEN DATE(a.date) BETWEEN CURRENT_DATE - INTERVAL '7 days' AND CURRENT_DATE
        WHEN $1::text = 'month' THEN DATE(a.date) BETWEEN CURRENT_DATE - INTERVAL '30 days' AND CURRENT_DATE
        ELSE TRUE
    END
GROUP BY s.state
`

type GetAppointmentsByStatusRow struct {
	State string `json:"state"`
	Count int64  `json:"count"`
}

// Thống kê số lượng lịch hẹn theo trạng thái và khoảng thời gian (ngày/tuần/tháng)
func (q *Queries) GetAppointmentsByStatus(ctx context.Context, dollar_1 string) ([]GetAppointmentsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAppointmentsByStatus, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAppointmentsByStatusRow{}
	for rows.Next() {
		var i GetAppointmentsByStatusRow
		if err := rows.Scan(&i.State, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAverageConfirmationTime = `-- name: GetAverageConfirmationTime :one
SELECT 
    AVG(EXTRACT(EPOCH FROM (updated_at - created_at))/3600) as avg_hours
FROM appointments a
JOIN states s ON a.state_id = s.id
WHERE 
    s.state = 'Confirmed' 
    AND date BETWEEN $1::timestamp AND $2::timestamp
`

type GetAverageConfirmationTimeParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

// Tính thời gian chờ trung bình từ lúc đặt đến lúc được xác nhận
func (q *Queries) GetAverageConfirmationTime(ctx context.Context, arg GetAverageConfirmationTimeParams) (float64, error) {
	row := q.db.QueryRow(ctx, getAverageConfirmationTime, arg.StartDate, arg.EndDate)
	var avg_hours float64
	err := row.Scan(&avg_hours)
	return avg_hours, err
}

const getDailyAppointmentStats = `-- name: GetDailyAppointmentStats :one
SELECT 
    COUNT(*) as total_appointments,
    COUNT(DISTINCT doctor_id) as total_doctors,
    COUNT(DISTINCT petid) as total_pets,
    ROUND(AVG(s.duration)::numeric, 2) as avg_duration_minutes
FROM appointments a
JOIN services s ON a.service_id = s.id
WHERE DATE(a.date) = CURRENT_DATE
`

type GetDailyAppointmentStatsRow struct {
	TotalAppointments  int64          `json:"total_appointments"`
	TotalDoctors       int64          `json:"total_doctors"`
	TotalPets          int64          `json:"total_pets"`
	AvgDurationMinutes pgtype.Numeric `json:"avg_duration_minutes"`
}

// Tính số lượng lịch hẹn, số lượng bác sĩ và thú cưng trong ngày
func (q *Queries) GetDailyAppointmentStats(ctx context.Context) (GetDailyAppointmentStatsRow, error) {
	row := q.db.QueryRow(ctx, getDailyAppointmentStats)
	var i GetDailyAppointmentStatsRow
	err := row.Scan(
		&i.TotalAppointments,
		&i.TotalDoctors,
		&i.TotalPets,
		&i.AvgDurationMinutes,
	)
	return i, err
}

const getDoctorAppointmentStats = `-- name: GetDoctorAppointmentStats :many
SELECT 
    d.id as doctor_id,
    u.full_name as doctor_name,
    COUNT(*) as total_appointments,
    COUNT(CASE WHEN st.state = 'Completed' THEN 1 END) as completed_appointments,
    ROUND(COUNT(CASE WHEN st.state = 'Completed' THEN 1 END)::numeric / COUNT(*)::numeric * 100, 2) as completion_rate
FROM appointments a
JOIN doctors d ON a.doctor_id = d.id
JOIN users u ON d.user_id = u.id
JOIN states st ON a.state_id = st.id
WHERE 
    date BETWEEN $1::timestamp AND $2::timestamp
GROUP BY d.id, u.full_name
ORDER BY total_appointments DESC
`

type GetDoctorAppointmentStatsParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
}

type GetDoctorAppointmentStatsRow struct {
	DoctorID              int64          `json:"doctor_id"`
	DoctorName            string         `json:"doctor_name"`
	TotalAppointments     int64          `json:"total_appointments"`
	CompletedAppointments int64          `json:"completed_appointments"`
	CompletionRate        pgtype.Numeric `json:"completion_rate"`
}

// Tính số ca khám trung bình mỗi bác sĩ/ngày
func (q *Queries) GetDoctorAppointmentStats(ctx context.Context, arg GetDoctorAppointmentStatsParams) ([]GetDoctorAppointmentStatsRow, error) {
	rows, err := q.db.Query(ctx, getDoctorAppointmentStats, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDoctorAppointmentStatsRow{}
	for rows.Next() {
		var i GetDoctorAppointmentStatsRow
		if err := rows.Scan(
			&i.DoctorID,
			&i.DoctorName,
			&i.TotalAppointments,
			&i.CompletedAppointments,
			&i.CompletionRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopBookedServices = `-- name: GetTopBookedServices :many
SELECT 
    s.id as service_id,
    s.name as service_name,
    COUNT(*) as booking_count,
    SUM(s.cost) as total_revenue
FROM appointments a
JOIN services s ON a.service_id = s.id
WHERE 
    date BETWEEN $1::timestamp AND $2::timestamp
GROUP BY s.id, s.name
ORDER BY booking_count DESC
LIMIT $3
`

type GetTopBookedServicesParams struct {
	StartDate pgtype.Timestamp `json:"start_date"`
	EndDate   pgtype.Timestamp `json:"end_date"`
	TopN      int32            `json:"top_n"`
}

type GetTopBookedServicesRow struct {
	ServiceID    int64       `json:"service_id"`
	ServiceName  pgtype.Text `json:"service_name"`
	BookingCount int64       `json:"booking_count"`
	TotalRevenue int64       `json:"total_revenue"`
}

// Lấy top 10 dịch vụ được đặt nhiều nhất
func (q *Queries) GetTopBookedServices(ctx context.Context, arg GetTopBookedServicesParams) ([]GetTopBookedServicesRow, error) {
	rows, err := q.db.Query(ctx, getTopBookedServices, arg.StartDate, arg.EndDate, arg.TopN)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopBookedServicesRow{}
	for rows.Next() {
		var i GetTopBookedServicesRow
		if err := rows.Scan(
			&i.ServiceID,
			&i.ServiceName,
			&i.BookingCount,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
