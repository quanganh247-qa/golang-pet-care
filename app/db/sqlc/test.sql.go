// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: test.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addOrderedTest = `-- name: AddOrderedTest :one
INSERT INTO ordered_tests (
    order_id,
    test_id,
    price_at_order
) VALUES (
    $1, $2, $3
) RETURNING id, order_id, test_id, price_at_order, status, results, results_date, technician_notes, created_at, updated_at
`

type AddOrderedTestParams struct {
	OrderID      pgtype.Int4 `json:"order_id"`
	TestID       pgtype.Int4 `json:"test_id"`
	PriceAtOrder float64     `json:"price_at_order"`
}

func (q *Queries) AddOrderedTest(ctx context.Context, arg AddOrderedTestParams) (OrderedTest, error) {
	row := q.db.QueryRow(ctx, addOrderedTest, arg.OrderID, arg.TestID, arg.PriceAtOrder)
	var i OrderedTest
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TestID,
		&i.PriceAtOrder,
		&i.Status,
		&i.Results,
		&i.ResultsDate,
		&i.TechnicianNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const addTestCategory = `-- name: AddTestCategory :exec








INSERT INTO test_categories (category_id, name, description, icon_name)
VALUES ($1, $2, $3, $4)
`

type AddTestCategoryParams struct {
	CategoryID  string      `json:"category_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	IconName    pgtype.Text `json:"icon_name"`
}

// -- name: CreateTest :one
// INSERT INTO tests (
//
//	pet_id,
//	doctor_id,
//	test_type,
//	status,
//	created_at
//
// ) VALUES (
//
//	$1, $2, $3, $4, CURRENT_TIMESTAMP
//
// ) RETURNING *;
// -- name: UpdateTestStatus :exec
// UPDATE tests
// SET status = $2,
//
//	updated_at = CURRENT_TIMESTAMP
//
// WHERE id = $1;
// -- name: GetTestByID :one
// SELECT * FROM tests WHERE id = $1;
// -- name: GetTestsByPetID :many
// SELECT * FROM tests WHERE pet_id = $1;
// -- name: GetTestsByDoctorID :many
// SELECT * FROM tests WHERE doctor_id = $1;
// -- name: AddTestResult :one
// INSERT INTO test_results (
//
//	test_id,
//	parameters,
//	notes,
//	files,
//	created_at
//
// ) VALUES (
//
//	$1, $2, $3, $4, CURRENT_TIMESTAMP
//
// ) RETURNING *;
// -- name: GetTestResults :many
// SELECT * FROM test_results WHERE test_id = $1;
// -- name: GetStatusHistory :many
// SELECT
//
//	status,
//	updated_at as timestamp,
//	updated_by
//
// FROM test_statuses
// WHERE test_id = $1
// ORDER BY updated_at DESC;
func (q *Queries) AddTestCategory(ctx context.Context, arg AddTestCategoryParams) error {
	_, err := q.db.Exec(ctx, addTestCategory,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.IconName,
	)
	return err
}

const addTestResult = `-- name: AddTestResult :one
INSERT INTO test_results (
    ordered_test_id, 
    parameter_name, 
    result_value, 
    normal_range, 
    units, 
    interpretation
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING result_id, ordered_test_id, parameter_name, result_value, normal_range, units, interpretation, created_at
`

type AddTestResultParams struct {
	OrderedTestID  pgtype.Int4 `json:"ordered_test_id"`
	ParameterName  string      `json:"parameter_name"`
	ResultValue    pgtype.Text `json:"result_value"`
	NormalRange    pgtype.Text `json:"normal_range"`
	Units          pgtype.Text `json:"units"`
	Interpretation pgtype.Text `json:"interpretation"`
}

func (q *Queries) AddTestResult(ctx context.Context, arg AddTestResultParams) (TestResult, error) {
	row := q.db.QueryRow(ctx, addTestResult,
		arg.OrderedTestID,
		arg.ParameterName,
		arg.ResultValue,
		arg.NormalRange,
		arg.Units,
		arg.Interpretation,
	)
	var i TestResult
	err := row.Scan(
		&i.ResultID,
		&i.OrderedTestID,
		&i.ParameterName,
		&i.ResultValue,
		&i.NormalRange,
		&i.Units,
		&i.Interpretation,
		&i.CreatedAt,
	)
	return i, err
}

const cancelTestOrder = `-- name: CancelTestOrder :exec
UPDATE test_orders 
SET status = 'cancelled'
WHERE order_id = $1 AND status IN ('pending', 'processing')
`

func (q *Queries) CancelTestOrder(ctx context.Context, orderID int32) error {
	_, err := q.db.Exec(ctx, cancelTestOrder, orderID)
	return err
}

const createTest = `-- name: CreateTest :one
INSERT INTO tests (test_id, category_id, name, description, price, turnaround_time)
VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, test_id, category_id, name, description, price, turnaround_time, is_active, created_at, updated_at
`

type CreateTestParams struct {
	TestID         string      `json:"test_id"`
	CategoryID     pgtype.Text `json:"category_id"`
	Name           string      `json:"name"`
	Description    pgtype.Text `json:"description"`
	Price          float64     `json:"price"`
	TurnaroundTime string      `json:"turnaround_time"`
}

func (q *Queries) CreateTest(ctx context.Context, arg CreateTestParams) (Test, error) {
	row := q.db.QueryRow(ctx, createTest,
		arg.TestID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.TurnaroundTime,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.TurnaroundTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTestOrder = `-- name: CreateTestOrder :one
INSERT INTO test_orders (
    appointment_id, 
    total_amount,
    notes
) VALUES (
    $1, $2, $3
) RETURNING order_id, appointment_id, order_date, status, total_amount, notes, created_at, updated_at
`

type CreateTestOrderParams struct {
	AppointmentID pgtype.Int4   `json:"appointment_id"`
	TotalAmount   pgtype.Float8 `json:"total_amount"`
	Notes         pgtype.Text   `json:"notes"`
}

func (q *Queries) CreateTestOrder(ctx context.Context, arg CreateTestOrderParams) (TestOrder, error) {
	row := q.db.QueryRow(ctx, createTestOrder, arg.AppointmentID, arg.TotalAmount, arg.Notes)
	var i TestOrder
	err := row.Scan(
		&i.OrderID,
		&i.AppointmentID,
		&i.OrderDate,
		&i.Status,
		&i.TotalAmount,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestByID = `-- name: GetTestByID :one
SELECT id, test_id, category_id, name, description, price, turnaround_time, is_active, created_at, updated_at FROM tests WHERE id = $1 AND is_active = true
`

func (q *Queries) GetTestByID(ctx context.Context, id int32) (Test, error) {
	row := q.db.QueryRow(ctx, getTestByID, id)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.TurnaroundTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestCategories = `-- name: GetTestCategories :many
SELECT id, category_id, name, description, icon_name, created_at, updated_at FROM test_categories
`

func (q *Queries) GetTestCategories(ctx context.Context) ([]TestCategory, error) {
	rows, err := q.db.Query(ctx, getTestCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TestCategory{}
	for rows.Next() {
		var i TestCategory
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.IconName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestCategoryByID = `-- name: GetTestCategoryByID :one
SELECT id, category_id, name, description, icon_name, created_at, updated_at FROM test_categories WHERE category_id = $1
`

func (q *Queries) GetTestCategoryByID(ctx context.Context, categoryID string) (TestCategory, error) {
	row := q.db.QueryRow(ctx, getTestCategoryByID, categoryID)
	var i TestCategory
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.IconName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTestsByCategory = `-- name: GetTestsByCategory :many
SELECT id, test_id, category_id, name, description, price, turnaround_time, is_active, created_at, updated_at FROM tests 
WHERE category_id = $1 AND is_active = TRUE
`

func (q *Queries) GetTestsByCategory(ctx context.Context, categoryID pgtype.Text) ([]Test, error) {
	rows, err := q.db.Query(ctx, getTestsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.TestID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.TurnaroundTime,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTests = `-- name: ListTests :many
SELECT id, test_id, category_id, name, description, price, turnaround_time, is_active, created_at, updated_at FROM tests WHERE is_active is true
`

func (q *Queries) ListTests(ctx context.Context) ([]Test, error) {
	rows, err := q.db.Query(ctx, listTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.TestID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.TurnaroundTime,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTest = `-- name: SoftDeleteTest :exec
UPDATE tests
SET is_active = false
WHERE test_id = $1
`

func (q *Queries) SoftDeleteTest(ctx context.Context, testID string) error {
	_, err := q.db.Exec(ctx, softDeleteTest, testID)
	return err
}

const updateTest = `-- name: UpdateTest :one
UPDATE tests
SET name = $2, description = $3, price = $4, turnaround_time = $5
WHERE test_id = $1
RETURNING id, test_id, category_id, name, description, price, turnaround_time, is_active, created_at, updated_at
`

type UpdateTestParams struct {
	TestID         string      `json:"test_id"`
	Name           string      `json:"name"`
	Description    pgtype.Text `json:"description"`
	Price          float64     `json:"price"`
	TurnaroundTime string      `json:"turnaround_time"`
}

func (q *Queries) UpdateTest(ctx context.Context, arg UpdateTestParams) (Test, error) {
	row := q.db.QueryRow(ctx, updateTest,
		arg.TestID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.TurnaroundTime,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.TestID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.TurnaroundTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTestStatus = `-- name: UpdateTestStatus :one
UPDATE ordered_tests
SET status = $2
WHERE id = $1
RETURNING id, order_id, test_id, price_at_order, status, results, results_date, technician_notes, created_at, updated_at
`

type UpdateTestStatusParams struct {
	ID     int32       `json:"id"`
	Status pgtype.Text `json:"status"`
}

func (q *Queries) UpdateTestStatus(ctx context.Context, arg UpdateTestStatusParams) (OrderedTest, error) {
	row := q.db.QueryRow(ctx, updateTestStatus, arg.ID, arg.Status)
	var i OrderedTest
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.TestID,
		&i.PriceAtOrder,
		&i.Status,
		&i.Results,
		&i.ResultsDate,
		&i.TechnicianNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
