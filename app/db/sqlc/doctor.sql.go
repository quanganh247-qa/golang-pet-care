// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: doctor.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

<<<<<<< HEAD
const createDoctor = `-- name: CreateDoctor :one
INSERT INTO doctors (
    user_id,
    specialization,
    years_of_experience,
    education,
    certificate_number,
    bio) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, specialization, years_of_experience, education, certificate_number, bio
`

type CreateDoctorParams struct {
	UserID            int64       `json:"user_id"`
	Specialization    pgtype.Text `json:"specialization"`
	YearsOfExperience pgtype.Int4 `json:"years_of_experience"`
	Education         pgtype.Text `json:"education"`
	CertificateNumber pgtype.Text `json:"certificate_number"`
	Bio               pgtype.Text `json:"bio"`
}

func (q *Queries) CreateDoctor(ctx context.Context, arg CreateDoctorParams) (Doctor, error) {
	row := q.db.QueryRow(ctx, createDoctor,
		arg.UserID,
		arg.Specialization,
		arg.YearsOfExperience,
		arg.Education,
		arg.CertificateNumber,
		arg.Bio,
	)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
=======
const createDoctorSchedule = `-- name: CreateDoctorSchedule :one
INSERT INTO doctorschedules (
    doctor_id,
    day_of_week,
    shift,
    start_time,
    end_time,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, doctor_id, day_of_week, shift, start_time, end_time, is_active, created_at, updated_at
`

type CreateDoctorScheduleParams struct {
	DoctorID  int32       `json:"doctor_id"`
	DayOfWeek pgtype.Text `json:"day_of_week"`
	Shift     string      `json:"shift"`
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
	IsActive  pgtype.Bool `json:"is_active"`
}

func (q *Queries) CreateDoctorSchedule(ctx context.Context, arg CreateDoctorScheduleParams) (Doctorschedule, error) {
	row := q.db.QueryRow(ctx, createDoctorSchedule,
		arg.DoctorID,
		arg.DayOfWeek,
		arg.Shift,
		arg.StartTime,
		arg.EndTime,
		arg.IsActive,
	)
	var i Doctorschedule
	err := row.Scan(
		&i.ID,
		&i.DoctorID,
		&i.DayOfWeek,
		&i.Shift,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
>>>>>>> e9037c6 (update sqlc)
	)
	return i, err
}

<<<<<<< HEAD
const deleteDoctor = `-- name: DeleteDoctor :exec
DELETE FROM doctors
WHERE id = $1
`

func (q *Queries) DeleteDoctor(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDoctor, id)
	return err
}

const getAvailableDoctors = `-- name: GetAvailableDoctors :many
SELECT DISTINCT
    d.id, d.user_id, d.specialization, d.years_of_experience, d.education, d.certificate_number, d.bio,
    u.full_name
FROM doctors d
JOIN users u ON d.user_id = u.id
JOIN time_slots ts ON ts.doctor_id = d.id
WHERE ts.date = $1
AND ts.booked_patients < ts.max_patients
`

type GetAvailableDoctorsRow struct {
	ID                int64       `json:"id"`
	UserID            int64       `json:"user_id"`
	Specialization    pgtype.Text `json:"specialization"`
	YearsOfExperience pgtype.Int4 `json:"years_of_experience"`
	Education         pgtype.Text `json:"education"`
	CertificateNumber pgtype.Text `json:"certificate_number"`
	Bio               pgtype.Text `json:"bio"`
	FullName          string      `json:"full_name"`
}

func (q *Queries) GetAvailableDoctors(ctx context.Context, date pgtype.Date) ([]GetAvailableDoctorsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableDoctors, date)
=======
const getDoctorSchedules = `-- name: GetDoctorSchedules :many
SELECT id, doctor_id, day_of_week, shift, start_time, end_time, is_active, created_at, updated_at FROM doctorschedules
WHERE doctor_id = $1 AND is_active = true
`

func (q *Queries) GetDoctorSchedules(ctx context.Context, doctorID int32) ([]Doctorschedule, error) {
	rows, err := q.db.Query(ctx, getDoctorSchedules, doctorID)
>>>>>>> e9037c6 (update sqlc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
<<<<<<< HEAD
	items := []GetAvailableDoctorsRow{}
	for rows.Next() {
		var i GetAvailableDoctorsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Specialization,
			&i.YearsOfExperience,
			&i.Education,
			&i.CertificateNumber,
			&i.Bio,
			&i.FullName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoctor = `-- name: GetDoctor :one
SELECT 
    d.id, d.user_id, d.specialization, d.years_of_experience, d.education, d.certificate_number, d.bio,
    u.full_name AS name,
    u.role,
    u.email
FROM doctors d
JOIN users u ON d.user_id = u.id
WHERE d.id = $1
`

type GetDoctorRow struct {
	ID                int64       `json:"id"`
	UserID            int64       `json:"user_id"`
	Specialization    pgtype.Text `json:"specialization"`
	YearsOfExperience pgtype.Int4 `json:"years_of_experience"`
	Education         pgtype.Text `json:"education"`
	CertificateNumber pgtype.Text `json:"certificate_number"`
	Bio               pgtype.Text `json:"bio"`
	Name              string      `json:"name"`
	Role              pgtype.Text `json:"role"`
	Email             string      `json:"email"`
}

func (q *Queries) GetDoctor(ctx context.Context, id int64) (GetDoctorRow, error) {
	row := q.db.QueryRow(ctx, getDoctor, id)
	var i GetDoctorRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
		&i.Name,
		&i.Role,
		&i.Email,
	)
	return i, err
}

const getDoctorByUserId = `-- name: GetDoctorByUserId :one
SELECT id, user_id, specialization, years_of_experience, education, certificate_number, bio FROM doctors
WHERE user_id = $1
`

func (q *Queries) GetDoctorByUserId(ctx context.Context, userID int64) (Doctor, error) {
	row := q.db.QueryRow(ctx, getDoctorByUserId, userID)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
	)
	return i, err
}

const getDoctorByUsername = `-- name: GetDoctorByUsername :one
SELECT 
    d.id, d.user_id, d.specialization, d.years_of_experience, d.education, d.certificate_number, d.bio,
    u.full_name AS name,
    u.role,
    u.email
FROM doctors d
JOIN users u ON d.user_id = u.id
WHERE u.username = $1
`

type GetDoctorByUsernameRow struct {
	ID                int64       `json:"id"`
	UserID            int64       `json:"user_id"`
	Specialization    pgtype.Text `json:"specialization"`
	YearsOfExperience pgtype.Int4 `json:"years_of_experience"`
	Education         pgtype.Text `json:"education"`
	CertificateNumber pgtype.Text `json:"certificate_number"`
	Bio               pgtype.Text `json:"bio"`
	Name              string      `json:"name"`
	Role              pgtype.Text `json:"role"`
	Email             string      `json:"email"`
}

func (q *Queries) GetDoctorByUsername(ctx context.Context, username string) (GetDoctorByUsernameRow, error) {
	row := q.db.QueryRow(ctx, getDoctorByUsername, username)
	var i GetDoctorByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
		&i.Name,
		&i.Role,
		&i.Email,
	)
	return i, err
}

const listDoctors = `-- name: ListDoctors :many
SELECT 
    d.id AS doctor_id,
    u.username,
    u.full_name,
    u.email,
    u.role,
    d.specialization,
    d.years_of_experience,
    d.education,
    d.certificate_number,
    d.bio
FROM doctors d
JOIN users u ON d.user_id = u.id
ORDER BY u.full_name
`

type ListDoctorsRow struct {
	DoctorID          int64       `json:"doctor_id"`
	Username          string      `json:"username"`
	FullName          string      `json:"full_name"`
	Email             string      `json:"email"`
	Role              pgtype.Text `json:"role"`
	Specialization    pgtype.Text `json:"specialization"`
	YearsOfExperience pgtype.Int4 `json:"years_of_experience"`
	Education         pgtype.Text `json:"education"`
	CertificateNumber pgtype.Text `json:"certificate_number"`
	Bio               pgtype.Text `json:"bio"`
}

func (q *Queries) ListDoctors(ctx context.Context) ([]ListDoctorsRow, error) {
	rows, err := q.db.Query(ctx, listDoctors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDoctorsRow{}
	for rows.Next() {
		var i ListDoctorsRow
		if err := rows.Scan(
			&i.DoctorID,
			&i.Username,
			&i.FullName,
			&i.Email,
			&i.Role,
			&i.Specialization,
			&i.YearsOfExperience,
			&i.Education,
			&i.CertificateNumber,
			&i.Bio,
=======
	items := []Doctorschedule{}
	for rows.Next() {
		var i Doctorschedule
		if err := rows.Scan(
			&i.ID,
			&i.DoctorID,
			&i.DayOfWeek,
			&i.Shift,
			&i.StartTime,
			&i.EndTime,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
>>>>>>> e9037c6 (update sqlc)
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

<<<<<<< HEAD
const updateDoctor = `-- name: UpdateDoctor :one
UPDATE doctors
SET 
    specialization = COALESCE($2, specialization),
    years_of_experience = COALESCE($3, years_of_experience),
    education = COALESCE($4, education),
    certificate_number = COALESCE($5, certificate_number),
    bio = COALESCE($6, bio)
    WHERE id = $1
RETURNING id, user_id, specialization, years_of_experience, education, certificate_number, bio
`

type UpdateDoctorParams struct {
	ID                int64       `json:"id"`
	Specialization    pgtype.Text `json:"specialization"`
	YearsOfExperience pgtype.Int4 `json:"years_of_experience"`
	Education         pgtype.Text `json:"education"`
	CertificateNumber pgtype.Text `json:"certificate_number"`
	Bio               pgtype.Text `json:"bio"`
}

func (q *Queries) UpdateDoctor(ctx context.Context, arg UpdateDoctorParams) (Doctor, error) {
	row := q.db.QueryRow(ctx, updateDoctor,
		arg.ID,
		arg.Specialization,
		arg.YearsOfExperience,
		arg.Education,
		arg.CertificateNumber,
		arg.Bio,
	)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
=======
const updateDoctorSchedule = `-- name: UpdateDoctorSchedule :one
UPDATE doctorschedules
SET 
    start_time = COALESCE($1, start_time),
    end_time = COALESCE($2, end_time),
    is_active = COALESCE($3, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $4
RETURNING id, doctor_id, day_of_week, shift, start_time, end_time, is_active, created_at, updated_at
`

type UpdateDoctorScheduleParams struct {
	StartTime pgtype.Time `json:"start_time"`
	EndTime   pgtype.Time `json:"end_time"`
	IsActive  pgtype.Bool `json:"is_active"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdateDoctorSchedule(ctx context.Context, arg UpdateDoctorScheduleParams) (Doctorschedule, error) {
	row := q.db.QueryRow(ctx, updateDoctorSchedule,
		arg.StartTime,
		arg.EndTime,
		arg.IsActive,
		arg.ID,
	)
	var i Doctorschedule
	err := row.Scan(
		&i.ID,
		&i.DoctorID,
		&i.DayOfWeek,
		&i.Shift,
		&i.StartTime,
		&i.EndTime,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
>>>>>>> e9037c6 (update sqlc)
	)
	return i, err
}
