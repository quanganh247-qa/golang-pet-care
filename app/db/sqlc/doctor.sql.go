// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: doctor.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDoctor = `-- name: CreateDoctor :one
INSERT INTO doctors (
    user_id,
    specialization,
    years_of_experience,
    education,
    certificate_number,
    bio,
    consultation_fee
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, specialization, years_of_experience, education, certificate_number, bio, consultation_fee
`

type CreateDoctorParams struct {
	UserID            int64         `json:"user_id"`
	Specialization    pgtype.Text   `json:"specialization"`
	YearsOfExperience pgtype.Int4   `json:"years_of_experience"`
	Education         pgtype.Text   `json:"education"`
	CertificateNumber pgtype.Text   `json:"certificate_number"`
	Bio               pgtype.Text   `json:"bio"`
	ConsultationFee   pgtype.Float8 `json:"consultation_fee"`
}

func (q *Queries) CreateDoctor(ctx context.Context, arg CreateDoctorParams) (Doctor, error) {
	row := q.db.QueryRow(ctx, createDoctor,
		arg.UserID,
		arg.Specialization,
		arg.YearsOfExperience,
		arg.Education,
		arg.CertificateNumber,
		arg.Bio,
		arg.ConsultationFee,
	)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
		&i.ConsultationFee,
	)
	return i, err
}

const deleteDoctor = `-- name: DeleteDoctor :exec
DELETE FROM doctors
WHERE id = $1
`

func (q *Queries) DeleteDoctor(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDoctor, id)
	return err
}

const getAvailableDoctors = `-- name: GetAvailableDoctors :many
SELECT DISTINCT
    d.id,
    u.full_name,
    d.specialization,
    d.consultation_fee
FROM doctors d
JOIN users u ON d.user_id = u.id
JOIN time_slots ts ON ts.doctor_id = d.id
WHERE ts.date = $1
AND ts.booked_patients < ts.max_patients
`

type GetAvailableDoctorsRow struct {
	ID              int64         `json:"id"`
	FullName        string        `json:"full_name"`
	Specialization  pgtype.Text   `json:"specialization"`
	ConsultationFee pgtype.Float8 `json:"consultation_fee"`
}

func (q *Queries) GetAvailableDoctors(ctx context.Context, date pgtype.Date) ([]GetAvailableDoctorsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableDoctors, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableDoctorsRow{}
	for rows.Next() {
		var i GetAvailableDoctorsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Specialization,
			&i.ConsultationFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoctor = `-- name: GetDoctor :one
SELECT 
    d.id,
    u.full_name AS name,
    d.specialization,
    d.years_of_experience,
    d.education,
    d.certificate_number,
    d.bio,
    d.consultation_fee
FROM doctors d
JOIN users u ON d.user_id = u.id
WHERE d.id = $1
`

type GetDoctorRow struct {
	ID                int64         `json:"id"`
	Name              string        `json:"name"`
	Specialization    pgtype.Text   `json:"specialization"`
	YearsOfExperience pgtype.Int4   `json:"years_of_experience"`
	Education         pgtype.Text   `json:"education"`
	CertificateNumber pgtype.Text   `json:"certificate_number"`
	Bio               pgtype.Text   `json:"bio"`
	ConsultationFee   pgtype.Float8 `json:"consultation_fee"`
}

func (q *Queries) GetDoctor(ctx context.Context, id int64) (GetDoctorRow, error) {
	row := q.db.QueryRow(ctx, getDoctor, id)
	var i GetDoctorRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
		&i.ConsultationFee,
	)
	return i, err
}

const getDoctorByUserId = `-- name: GetDoctorByUserId :one
SELECT id, user_id, specialization, years_of_experience, education, certificate_number, bio, consultation_fee FROM doctors
WHERE user_id = $1
`

func (q *Queries) GetDoctorByUserId(ctx context.Context, userID int64) (Doctor, error) {
	row := q.db.QueryRow(ctx, getDoctorByUserId, userID)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
		&i.ConsultationFee,
	)
	return i, err
}

const listDoctors = `-- name: ListDoctors :many
SELECT 
    d.id AS doctor_id,
    u.username,
    u.full_name,
    u.email,
    d.specialization,
    d.years_of_experience,
    d.education,
    d.certificate_number,
    d.bio,
    d.consultation_fee
FROM doctors d
JOIN users u ON d.user_id = u.id
ORDER BY u.full_name
`

type ListDoctorsRow struct {
	DoctorID          int64         `json:"doctor_id"`
	Username          string        `json:"username"`
	FullName          string        `json:"full_name"`
	Email             string        `json:"email"`
	Specialization    pgtype.Text   `json:"specialization"`
	YearsOfExperience pgtype.Int4   `json:"years_of_experience"`
	Education         pgtype.Text   `json:"education"`
	CertificateNumber pgtype.Text   `json:"certificate_number"`
	Bio               pgtype.Text   `json:"bio"`
	ConsultationFee   pgtype.Float8 `json:"consultation_fee"`
}

func (q *Queries) ListDoctors(ctx context.Context) ([]ListDoctorsRow, error) {
	rows, err := q.db.Query(ctx, listDoctors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDoctorsRow{}
	for rows.Next() {
		var i ListDoctorsRow
		if err := rows.Scan(
			&i.DoctorID,
			&i.Username,
			&i.FullName,
			&i.Email,
			&i.Specialization,
			&i.YearsOfExperience,
			&i.Education,
			&i.CertificateNumber,
			&i.Bio,
			&i.ConsultationFee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDoctor = `-- name: UpdateDoctor :one
UPDATE doctors
SET 
    specialization = COALESCE($2, specialization),
    years_of_experience = COALESCE($3, years_of_experience),
    education = COALESCE($4, education),
    certificate_number = COALESCE($5, certificate_number),
    bio = COALESCE($6, bio),
    consultation_fee = COALESCE($7, consultation_fee)
WHERE id = $1
RETURNING id, user_id, specialization, years_of_experience, education, certificate_number, bio, consultation_fee
`

type UpdateDoctorParams struct {
	ID                int64         `json:"id"`
	Specialization    pgtype.Text   `json:"specialization"`
	YearsOfExperience pgtype.Int4   `json:"years_of_experience"`
	Education         pgtype.Text   `json:"education"`
	CertificateNumber pgtype.Text   `json:"certificate_number"`
	Bio               pgtype.Text   `json:"bio"`
	ConsultationFee   pgtype.Float8 `json:"consultation_fee"`
}

func (q *Queries) UpdateDoctor(ctx context.Context, arg UpdateDoctorParams) (Doctor, error) {
	row := q.db.QueryRow(ctx, updateDoctor,
		arg.ID,
		arg.Specialization,
		arg.YearsOfExperience,
		arg.Education,
		arg.CertificateNumber,
		arg.Bio,
		arg.ConsultationFee,
	)
	var i Doctor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Specialization,
		&i.YearsOfExperience,
		&i.Education,
		&i.CertificateNumber,
		&i.Bio,
		&i.ConsultationFee,
	)
	return i, err
}
