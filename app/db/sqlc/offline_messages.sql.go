// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: offline_messages.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOfflineMessage = `-- name: CreateOfflineMessage :one
INSERT INTO offline_messages (
    client_id,
    username,
    message_type,
    data,
    status,
    retry_count
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, client_id, username, message_type, data, created_at, delivered_at, status, retry_count
`

type CreateOfflineMessageParams struct {
	ClientID    string `json:"client_id"`
	Username    string `json:"username"`
	MessageType string `json:"message_type"`
	Data        []byte `json:"data"`
	Status      string `json:"status"`
	RetryCount  int32  `json:"retry_count"`
}

func (q *Queries) CreateOfflineMessage(ctx context.Context, arg CreateOfflineMessageParams) (OfflineMessage, error) {
	row := q.db.QueryRow(ctx, createOfflineMessage,
		arg.ClientID,
		arg.Username,
		arg.MessageType,
		arg.Data,
		arg.Status,
		arg.RetryCount,
	)
	var i OfflineMessage
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Username,
		&i.MessageType,
		&i.Data,
		&i.CreatedAt,
		&i.DeliveredAt,
		&i.Status,
		&i.RetryCount,
	)
	return i, err
}

const deleteOldMessages = `-- name: DeleteOldMessages :exec
DELETE FROM offline_messages
WHERE status = $1 AND created_at < $2
`

type DeleteOldMessagesParams struct {
	Status    string             `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) DeleteOldMessages(ctx context.Context, arg DeleteOldMessagesParams) error {
	_, err := q.db.Exec(ctx, deleteOldMessages, arg.Status, arg.CreatedAt)
	return err
}

const getMessagesForRetry = `-- name: GetMessagesForRetry :many
SELECT id, client_id, username, message_type, data, created_at, delivered_at, status, retry_count FROM offline_messages
WHERE status = ANY($1::varchar[]) AND retry_count < $2
ORDER BY created_at ASC
`

type GetMessagesForRetryParams struct {
	Column1    []string `json:"column_1"`
	RetryCount int32    `json:"retry_count"`
}

func (q *Queries) GetMessagesForRetry(ctx context.Context, arg GetMessagesForRetryParams) ([]OfflineMessage, error) {
	rows, err := q.db.Query(ctx, getMessagesForRetry, arg.Column1, arg.RetryCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OfflineMessage{}
	for rows.Next() {
		var i OfflineMessage
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Username,
			&i.MessageType,
			&i.Data,
			&i.CreatedAt,
			&i.DeliveredAt,
			&i.Status,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingMessagesForClient = `-- name: GetPendingMessagesForClient :many
SELECT id, client_id, username, message_type, data, created_at, delivered_at, status, retry_count FROM offline_messages
WHERE  status = 'pending'
ORDER BY created_at ASC
`

func (q *Queries) GetPendingMessagesForClient(ctx context.Context) ([]OfflineMessage, error) {
	rows, err := q.db.Query(ctx, getPendingMessagesForClient)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OfflineMessage{}
	for rows.Next() {
		var i OfflineMessage
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Username,
			&i.MessageType,
			&i.Data,
			&i.CreatedAt,
			&i.DeliveredAt,
			&i.Status,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementMessageRetryCount = `-- name: IncrementMessageRetryCount :exec
UPDATE offline_messages
SET 
    retry_count = retry_count + 1,
    status = CASE 
        WHEN retry_count >= 5 THEN 'failed'
        ELSE 'pending'
    END
WHERE id = $1
`

func (q *Queries) IncrementMessageRetryCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementMessageRetryCount, id)
	return err
}

const markMessageDelivered = `-- name: MarkMessageDelivered :exec
UPDATE offline_messages
SET 
    status = 'delivered',
    delivered_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkMessageDelivered(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markMessageDelivered, id)
	return err
}
