// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: product.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllProducts = `-- name: GetAllProducts :many
SELECT product_id, name, description, price, stock_quantity, category, data_image, original_image, created_at, is_available, removed_at, expiration_date, reorder_level, supplier_id, updated_at from Products  ORDER BY name  LIMIT $1 OFFSET $2
`

type GetAllProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProducts(ctx context.Context, arg GetAllProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getAllProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.StockQuantity,
			&i.Category,
			&i.DataImage,
			&i.OriginalImage,
			&i.CreatedAt,
			&i.IsAvailable,
			&i.RemovedAt,
			&i.ExpirationDate,
			&i.ReorderLevel,
			&i.SupplierID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT product_id, name, description, price, stock_quantity, category, data_image, original_image, created_at, is_available, removed_at, expiration_date, reorder_level, supplier_id, updated_at from Products where product_id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, productID int64) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.StockQuantity,
		&i.Category,
		&i.DataImage,
		&i.OriginalImage,
		&i.CreatedAt,
		&i.IsAvailable,
		&i.RemovedAt,
		&i.ExpirationDate,
		&i.ReorderLevel,
		&i.SupplierID,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByIDForUpdate = `-- name: GetProductByIDForUpdate :one
SELECT product_id, name, description, price, stock_quantity, category, data_image, original_image, created_at, is_available, removed_at, expiration_date, reorder_level, supplier_id, updated_at from Products where product_id = $1 FOR NO KEY UPDATE
`

func (q *Queries) GetProductByIDForUpdate(ctx context.Context, productID int64) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByIDForUpdate, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.StockQuantity,
		&i.Category,
		&i.DataImage,
		&i.OriginalImage,
		&i.CreatedAt,
		&i.IsAvailable,
		&i.RemovedAt,
		&i.ExpirationDate,
		&i.ReorderLevel,
		&i.SupplierID,
		&i.UpdatedAt,
	)
	return i, err
}

const insertProduct = `-- name: InsertProduct :one
INSERT INTO Products (name, description, price, category, stock_quantity,data_image,original_image,created_at,is_available) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING product_id, name, description, price, stock_quantity, category, data_image, original_image, created_at, is_available, removed_at, expiration_date, reorder_level, supplier_id, updated_at
`

type InsertProductParams struct {
	Name          string           `json:"name"`
	Description   pgtype.Text      `json:"description"`
	Price         float64          `json:"price"`
	Category      pgtype.Text      `json:"category"`
	StockQuantity pgtype.Int4      `json:"stock_quantity"`
	DataImage     []byte           `json:"data_image"`
	OriginalImage pgtype.Text      `json:"original_image"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	IsAvailable   pgtype.Bool      `json:"is_available"`
}

func (q *Queries) InsertProduct(ctx context.Context, arg InsertProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, insertProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Category,
		arg.StockQuantity,
		arg.DataImage,
		arg.OriginalImage,
		arg.CreatedAt,
		arg.IsAvailable,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.StockQuantity,
		&i.Category,
		&i.DataImage,
		&i.OriginalImage,
		&i.CreatedAt,
		&i.IsAvailable,
		&i.RemovedAt,
		&i.ExpirationDate,
		&i.ReorderLevel,
		&i.SupplierID,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductStock = `-- name: UpdateProductStock :one
UPDATE Products
SET stock_quantity = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE product_id = $1
RETURNING product_id, name, description, price, stock_quantity, category, data_image, original_image, created_at, is_available, removed_at, expiration_date, reorder_level, supplier_id, updated_at
`

type UpdateProductStockParams struct {
	ProductID     int64       `json:"product_id"`
	StockQuantity pgtype.Int4 `json:"stock_quantity"`
}

func (q *Queries) UpdateProductStock(ctx context.Context, arg UpdateProductStockParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProductStock, arg.ProductID, arg.StockQuantity)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.StockQuantity,
		&i.Category,
		&i.DataImage,
		&i.OriginalImage,
		&i.CreatedAt,
		&i.IsAvailable,
		&i.RemovedAt,
		&i.ExpirationDate,
		&i.ReorderLevel,
		&i.SupplierID,
		&i.UpdatedAt,
	)
	return i, err
}
