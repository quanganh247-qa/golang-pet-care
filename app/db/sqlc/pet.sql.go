// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: pet.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPet = `-- name: CreatePet :one
INSERT INTO pets (
    name,
    type,
    breed,
    age,
    gender,
    healthnotes,
    weight,
    birth_date,
    username,
    microchip_number,
    last_checkup_date,
    is_active,
    data_image,
    original_image
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, true, $12, $13
) RETURNING petid, name, type, breed, age, gender, healthnotes, weight, birth_date, username, microchip_number, last_checkup_date, is_active, data_image, original_image
`

type CreatePetParams struct {
	Name            string        `json:"name"`
	Type            string        `json:"type"`
	Breed           pgtype.Text   `json:"breed"`
	Age             pgtype.Int4   `json:"age"`
	Gender          pgtype.Text   `json:"gender"`
	Healthnotes     pgtype.Text   `json:"healthnotes"`
	Weight          pgtype.Float8 `json:"weight"`
	BirthDate       pgtype.Date   `json:"birth_date"`
	Username        string        `json:"username"`
	MicrochipNumber pgtype.Text   `json:"microchip_number"`
	LastCheckupDate pgtype.Date   `json:"last_checkup_date"`
	DataImage       []byte        `json:"data_image"`
	OriginalImage   pgtype.Text   `json:"original_image"`
}

func (q *Queries) CreatePet(ctx context.Context, arg CreatePetParams) (Pet, error) {
	row := q.db.QueryRow(ctx, createPet,
		arg.Name,
		arg.Type,
		arg.Breed,
		arg.Age,
		arg.Gender,
		arg.Healthnotes,
		arg.Weight,
		arg.BirthDate,
		arg.Username,
		arg.MicrochipNumber,
		arg.LastCheckupDate,
		arg.DataImage,
		arg.OriginalImage,
	)
	var i Pet
	err := row.Scan(
		&i.Petid,
		&i.Name,
		&i.Type,
		&i.Breed,
		&i.Age,
		&i.Gender,
		&i.Healthnotes,
		&i.Weight,
		&i.BirthDate,
		&i.Username,
		&i.MicrochipNumber,
		&i.LastCheckupDate,
		&i.IsActive,
		&i.DataImage,
		&i.OriginalImage,
	)
	return i, err
}

const deletePet = `-- name: DeletePet :exec
DELETE FROM pets WHERE petid = $1
`

func (q *Queries) DeletePet(ctx context.Context, petid int64) error {
	_, err := q.db.Exec(ctx, deletePet, petid)
	return err
}

const getAllPets = `-- name: GetAllPets :many
SELECT petid, name, type, breed, age, gender, healthnotes, weight, birth_date, username, microchip_number, last_checkup_date, is_active, data_image, original_image FROM pets WHERE is_active is true
`

func (q *Queries) GetAllPets(ctx context.Context) ([]Pet, error) {
	rows, err := q.db.Query(ctx, getAllPets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pet{}
	for rows.Next() {
		var i Pet
		if err := rows.Scan(
			&i.Petid,
			&i.Name,
			&i.Type,
			&i.Breed,
			&i.Age,
			&i.Gender,
			&i.Healthnotes,
			&i.Weight,
			&i.BirthDate,
			&i.Username,
			&i.MicrochipNumber,
			&i.LastCheckupDate,
			&i.IsActive,
			&i.DataImage,
			&i.OriginalImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPetByID = `-- name: GetPetByID :one
SELECT petid, name, type, breed, age, gender, healthnotes, weight, birth_date, username, microchip_number, last_checkup_date, is_active, data_image, original_image FROM pets 
WHERE petid = $1
`

func (q *Queries) GetPetByID(ctx context.Context, petid int64) (Pet, error) {
	row := q.db.QueryRow(ctx, getPetByID, petid)
	var i Pet
	err := row.Scan(
		&i.Petid,
		&i.Name,
		&i.Type,
		&i.Breed,
		&i.Age,
		&i.Gender,
		&i.Healthnotes,
		&i.Weight,
		&i.BirthDate,
		&i.Username,
		&i.MicrochipNumber,
		&i.LastCheckupDate,
		&i.IsActive,
		&i.DataImage,
		&i.OriginalImage,
	)
	return i, err
}

const listPets = `-- name: ListPets :many
SELECT petid, name, type, breed, age, gender, healthnotes, weight, birth_date, username, microchip_number, last_checkup_date, is_active, data_image, original_image FROM pets
WHERE is_active = true 
ORDER BY name LIMIT $1 OFFSET $2
`

type ListPetsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPets(ctx context.Context, arg ListPetsParams) ([]Pet, error) {
	rows, err := q.db.Query(ctx, listPets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pet{}
	for rows.Next() {
		var i Pet
		if err := rows.Scan(
			&i.Petid,
			&i.Name,
			&i.Type,
			&i.Breed,
			&i.Age,
			&i.Gender,
			&i.Healthnotes,
			&i.Weight,
			&i.BirthDate,
			&i.Username,
			&i.MicrochipNumber,
			&i.LastCheckupDate,
			&i.IsActive,
			&i.DataImage,
			&i.OriginalImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPetsByUsername = `-- name: ListPetsByUsername :many
SELECT petid, name, type, breed, age, gender, healthnotes, weight, birth_date, username, microchip_number, last_checkup_date, is_active, data_image, original_image FROM pets
WHERE username = $1 AND is_active = true
ORDER BY name LIMIT $2 OFFSET $3
`

type ListPetsByUsernameParams struct {
	Username string `json:"username"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListPetsByUsername(ctx context.Context, arg ListPetsByUsernameParams) ([]Pet, error) {
	rows, err := q.db.Query(ctx, listPetsByUsername, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Pet{}
	for rows.Next() {
		var i Pet
		if err := rows.Scan(
			&i.Petid,
			&i.Name,
			&i.Type,
			&i.Breed,
			&i.Age,
			&i.Gender,
			&i.Healthnotes,
			&i.Weight,
			&i.BirthDate,
			&i.Username,
			&i.MicrochipNumber,
			&i.LastCheckupDate,
			&i.IsActive,
			&i.DataImage,
			&i.OriginalImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setPetInactive = `-- name: SetPetInactive :exec
UPDATE pets
SET is_active = false
WHERE petid = $1
`

func (q *Queries) SetPetInactive(ctx context.Context, petid int64) error {
	_, err := q.db.Exec(ctx, setPetInactive, petid)
	return err
}

const updatePet = `-- name: UpdatePet :exec
UPDATE pets
SET 
    name = $2,
    type = $3,
    breed = $4,
    age = $5,
    gender = $6,
    healthnotes = $7,
    weight = $8,
    birth_date = $9,
    microchip_number = $10,
    last_checkup_date = $11
WHERE petid = $1
`

type UpdatePetParams struct {
	Petid           int64         `json:"petid"`
	Name            string        `json:"name"`
	Type            string        `json:"type"`
	Breed           pgtype.Text   `json:"breed"`
	Age             pgtype.Int4   `json:"age"`
	Gender          pgtype.Text   `json:"gender"`
	Healthnotes     pgtype.Text   `json:"healthnotes"`
	Weight          pgtype.Float8 `json:"weight"`
	BirthDate       pgtype.Date   `json:"birth_date"`
	MicrochipNumber pgtype.Text   `json:"microchip_number"`
	LastCheckupDate pgtype.Date   `json:"last_checkup_date"`
}

func (q *Queries) UpdatePet(ctx context.Context, arg UpdatePetParams) error {
	_, err := q.db.Exec(ctx, updatePet,
		arg.Petid,
		arg.Name,
		arg.Type,
		arg.Breed,
		arg.Age,
		arg.Gender,
		arg.Healthnotes,
		arg.Weight,
		arg.BirthDate,
		arg.MicrochipNumber,
		arg.LastCheckupDate,
	)
	return err
}

const updatePetAvatar = `-- name: UpdatePetAvatar :exec
UPDATE pets
SET 
    data_image = $2,
    original_image = $3
WHERE petid = $1
`

type UpdatePetAvatarParams struct {
	Petid         int64       `json:"petid"`
	DataImage     []byte      `json:"data_image"`
	OriginalImage pgtype.Text `json:"original_image"`
}

func (q *Queries) UpdatePetAvatar(ctx context.Context, arg UpdatePetAvatarParams) error {
	_, err := q.db.Exec(ctx, updatePetAvatar, arg.Petid, arg.DataImage, arg.OriginalImage)
	return err
}
