// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: product_transaction.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProductTransaction = `-- name: CreateProductTransaction :one
INSERT INTO product_transactions (
  product_id,
  quantity,
  transaction_type,
  unit_price,
  total_amount,
  supplier_id,
  expiration_date,
  notes,
  order_id,
  created_by
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, product_id, quantity, transaction_type, unit_price, total_amount, transaction_date, supplier_id, expiration_date, notes, order_id, created_by, created_at
`

type CreateProductTransactionParams struct {
	ProductID       int64         `json:"product_id"`
	Quantity        int64         `json:"quantity"`
	TransactionType string        `json:"transaction_type"`
	UnitPrice       pgtype.Float8 `json:"unit_price"`
	TotalAmount     pgtype.Float8 `json:"total_amount"`
	SupplierID      pgtype.Int8   `json:"supplier_id"`
	ExpirationDate  pgtype.Date   `json:"expiration_date"`
	Notes           pgtype.Text   `json:"notes"`
	OrderID         pgtype.Int8   `json:"order_id"`
	CreatedBy       pgtype.Text   `json:"created_by"`
}

func (q *Queries) CreateProductTransaction(ctx context.Context, arg CreateProductTransactionParams) (ProductTransaction, error) {
	row := q.db.QueryRow(ctx, createProductTransaction,
		arg.ProductID,
		arg.Quantity,
		arg.TransactionType,
		arg.UnitPrice,
		arg.TotalAmount,
		arg.SupplierID,
		arg.ExpirationDate,
		arg.Notes,
		arg.OrderID,
		arg.CreatedBy,
	)
	var i ProductTransaction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.TransactionType,
		&i.UnitPrice,
		&i.TotalAmount,
		&i.TransactionDate,
		&i.SupplierID,
		&i.ExpirationDate,
		&i.Notes,
		&i.OrderID,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getExpiringProducts = `-- name: GetExpiringProducts :many
SELECT 
    p.product_id,
    p.name,
    p.expiration_date,
    (p.expiration_date - CURRENT_DATE) as days_until_expiry,
    p.stock_quantity
FROM products p
WHERE 
    p.expiration_date IS NOT NULL
    AND p.expiration_date <= $1::date  -- Pass a date parameter
    AND p.expiration_date >= CURRENT_DATE
    AND p.stock_quantity > 0
ORDER BY p.expiration_date ASC
`

type GetExpiringProductsRow struct {
	ProductID       int64       `json:"product_id"`
	Name            string      `json:"name"`
	ExpirationDate  pgtype.Date `json:"expiration_date"`
	DaysUntilExpiry int32       `json:"days_until_expiry"`
	StockQuantity   pgtype.Int4 `json:"stock_quantity"`
}

func (q *Queries) GetExpiringProducts(ctx context.Context, dollar_1 pgtype.Date) ([]GetExpiringProductsRow, error) {
	rows, err := q.db.Query(ctx, getExpiringProducts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpiringProductsRow{}
	for rows.Next() {
		var i GetExpiringProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.ExpirationDate,
			&i.DaysUntilExpiry,
			&i.StockQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockProducts = `-- name: GetLowStockProducts :many
SELECT 
    p.product_id,
    p.name,
    p.stock_quantity as current_stock,
    p.reorder_level
FROM 
    products p
WHERE 
    p.stock_quantity < p.reorder_level
ORDER BY 
    (p.reorder_level - p.stock_quantity) DESC
`

type GetLowStockProductsRow struct {
	ProductID    int64       `json:"product_id"`
	Name         string      `json:"name"`
	CurrentStock pgtype.Int4 `json:"current_stock"`
	ReorderLevel pgtype.Int4 `json:"reorder_level"`
}

func (q *Queries) GetLowStockProducts(ctx context.Context) ([]GetLowStockProductsRow, error) {
	rows, err := q.db.Query(ctx, getLowStockProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLowStockProductsRow{}
	for rows.Next() {
		var i GetLowStockProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.CurrentStock,
			&i.ReorderLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductTransactions = `-- name: GetProductTransactions :many
SELECT 
  pt.id, pt.product_id, pt.quantity, pt.transaction_type, pt.unit_price, pt.total_amount, pt.transaction_date, pt.supplier_id, pt.expiration_date, pt.notes, pt.order_id, pt.created_by, pt.created_at,
  p.name as product_name,
  COALESCE(ms.name, '') as supplier_name
FROM product_transactions pt
JOIN products p ON pt.product_id = p.product_id
LEFT JOIN medicine_suppliers ms ON pt.supplier_id = ms.id
ORDER BY pt.transaction_date DESC
LIMIT $1 OFFSET $2
`

type GetProductTransactionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductTransactionsRow struct {
	ID              int64              `json:"id"`
	ProductID       int64              `json:"product_id"`
	Quantity        int64              `json:"quantity"`
	TransactionType string             `json:"transaction_type"`
	UnitPrice       pgtype.Float8      `json:"unit_price"`
	TotalAmount     pgtype.Float8      `json:"total_amount"`
	TransactionDate pgtype.Timestamptz `json:"transaction_date"`
	SupplierID      pgtype.Int8        `json:"supplier_id"`
	ExpirationDate  pgtype.Date        `json:"expiration_date"`
	Notes           pgtype.Text        `json:"notes"`
	OrderID         pgtype.Int8        `json:"order_id"`
	CreatedBy       pgtype.Text        `json:"created_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	ProductName     string             `json:"product_name"`
	SupplierName    string             `json:"supplier_name"`
}

func (q *Queries) GetProductTransactions(ctx context.Context, arg GetProductTransactionsParams) ([]GetProductTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getProductTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductTransactionsRow{}
	for rows.Next() {
		var i GetProductTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.TransactionType,
			&i.UnitPrice,
			&i.TotalAmount,
			&i.TransactionDate,
			&i.SupplierID,
			&i.ExpirationDate,
			&i.Notes,
			&i.OrderID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ProductName,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductTransactionsByDate = `-- name: GetProductTransactionsByDate :many
SELECT 
  pt.id, pt.product_id, pt.quantity, pt.transaction_type, pt.unit_price, pt.total_amount, pt.transaction_date, pt.supplier_id, pt.expiration_date, pt.notes, pt.order_id, pt.created_by, pt.created_at,
  p.name as product_name,
  COALESCE(ms.name, '') as supplier_name
FROM product_transactions pt
JOIN products p ON pt.product_id = p.product_id
LEFT JOIN medicine_suppliers ms ON pt.supplier_id = ms.id
WHERE pt.transaction_date BETWEEN $1 AND $2
ORDER BY pt.transaction_date DESC
`

type GetProductTransactionsByDateParams struct {
	TransactionDate   pgtype.Timestamptz `json:"transaction_date"`
	TransactionDate_2 pgtype.Timestamptz `json:"transaction_date_2"`
}

type GetProductTransactionsByDateRow struct {
	ID              int64              `json:"id"`
	ProductID       int64              `json:"product_id"`
	Quantity        int64              `json:"quantity"`
	TransactionType string             `json:"transaction_type"`
	UnitPrice       pgtype.Float8      `json:"unit_price"`
	TotalAmount     pgtype.Float8      `json:"total_amount"`
	TransactionDate pgtype.Timestamptz `json:"transaction_date"`
	SupplierID      pgtype.Int8        `json:"supplier_id"`
	ExpirationDate  pgtype.Date        `json:"expiration_date"`
	Notes           pgtype.Text        `json:"notes"`
	OrderID         pgtype.Int8        `json:"order_id"`
	CreatedBy       pgtype.Text        `json:"created_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	ProductName     string             `json:"product_name"`
	SupplierName    string             `json:"supplier_name"`
}

func (q *Queries) GetProductTransactionsByDate(ctx context.Context, arg GetProductTransactionsByDateParams) ([]GetProductTransactionsByDateRow, error) {
	rows, err := q.db.Query(ctx, getProductTransactionsByDate, arg.TransactionDate, arg.TransactionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductTransactionsByDateRow{}
	for rows.Next() {
		var i GetProductTransactionsByDateRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.TransactionType,
			&i.UnitPrice,
			&i.TotalAmount,
			&i.TransactionDate,
			&i.SupplierID,
			&i.ExpirationDate,
			&i.Notes,
			&i.OrderID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ProductName,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductTransactionsByProductID = `-- name: GetProductTransactionsByProductID :many
SELECT 
  pt.id, pt.product_id, pt.quantity, pt.transaction_type, pt.unit_price, pt.total_amount, pt.transaction_date, pt.supplier_id, pt.expiration_date, pt.notes, pt.order_id, pt.created_by, pt.created_at,
  p.name as product_name,
  COALESCE(ms.name, '') as supplier_name
FROM product_transactions pt
JOIN products p ON pt.product_id = p.product_id
LEFT JOIN medicine_suppliers ms ON pt.supplier_id = ms.id
WHERE pt.product_id = $1
ORDER BY pt.transaction_date DESC
LIMIT $2 OFFSET $3
`

type GetProductTransactionsByProductIDParams struct {
	ProductID int64 `json:"product_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

type GetProductTransactionsByProductIDRow struct {
	ID              int64              `json:"id"`
	ProductID       int64              `json:"product_id"`
	Quantity        int64              `json:"quantity"`
	TransactionType string             `json:"transaction_type"`
	UnitPrice       pgtype.Float8      `json:"unit_price"`
	TotalAmount     pgtype.Float8      `json:"total_amount"`
	TransactionDate pgtype.Timestamptz `json:"transaction_date"`
	SupplierID      pgtype.Int8        `json:"supplier_id"`
	ExpirationDate  pgtype.Date        `json:"expiration_date"`
	Notes           pgtype.Text        `json:"notes"`
	OrderID         pgtype.Int8        `json:"order_id"`
	CreatedBy       pgtype.Text        `json:"created_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	ProductName     string             `json:"product_name"`
	SupplierName    string             `json:"supplier_name"`
}

func (q *Queries) GetProductTransactionsByProductID(ctx context.Context, arg GetProductTransactionsByProductIDParams) ([]GetProductTransactionsByProductIDRow, error) {
	rows, err := q.db.Query(ctx, getProductTransactionsByProductID, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductTransactionsByProductIDRow{}
	for rows.Next() {
		var i GetProductTransactionsByProductIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.TransactionType,
			&i.UnitPrice,
			&i.TotalAmount,
			&i.TransactionDate,
			&i.SupplierID,
			&i.ExpirationDate,
			&i.Notes,
			&i.OrderID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ProductName,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
