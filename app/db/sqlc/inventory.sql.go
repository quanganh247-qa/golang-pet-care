// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: inventory.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInventoryItems = `-- name: CountInventoryItems :one
SELECT COUNT(*)
FROM inventory_items i
WHERE 
    ($1::inventory_item_type_enum IS NULL OR i.item_type = $1)
    AND ($2::text IS NULL OR i.name ILIKE '%' || $2 || '%')
    AND ($3::boolean IS NULL OR i.is_active = $3)
    AND ($4::boolean IS NULL OR (i.quantity <= i.reorder_level) = $4)
    AND ($5::boolean IS NULL OR (i.expiration_date IS NOT NULL AND i.expiration_date < CURRENT_DATE) = $5)
    AND ($6::bigint IS NULL OR i.supplier_id = $6)
    AND ($7::text IS NULL OR i.for_species = $7)
    AND ($8::boolean IS NULL OR i.requires_prescription = $8)
`

type CountInventoryItemsParams struct {
	Column1 InventoryItemTypeEnum `json:"column_1"`
	Column2 string                `json:"column_2"`
	Column3 bool                  `json:"column_3"`
	Column4 bool                  `json:"column_4"`
	Column5 bool                  `json:"column_5"`
	Column6 int64                 `json:"column_6"`
	Column7 string                `json:"column_7"`
	Column8 bool                  `json:"column_8"`
}

func (q *Queries) CountInventoryItems(ctx context.Context, arg CountInventoryItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInventoryItems,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countInventoryTransactions = `-- name: CountInventoryTransactions :one
SELECT COUNT(*)
FROM 
    inventory_transactions t
JOIN 
    inventory_items i ON t.inventory_item_id = i.id
WHERE 
    ($1::bigint IS NULL OR t.inventory_item_id = $1)
    AND ($2::inventory_item_type_enum IS NULL OR i.item_type = $2)
    AND ($3::text IS NULL OR t.transaction_type = $3)
    AND ($4::bigint IS NULL OR t.supplier_id = $4)
    AND ($5::timestamptz IS NULL OR t.transaction_date >= $5)
    AND ($6::timestamptz IS NULL OR t.transaction_date <= $6)
    AND ($7::text IS NULL OR t.reference_type = $7)
    AND ($8::bigint IS NULL OR t.reference_id = $8)
    AND ($9::text IS NULL OR t.created_by = $9)
`

type CountInventoryTransactionsParams struct {
	Column1 int64                 `json:"column_1"`
	Column2 InventoryItemTypeEnum `json:"column_2"`
	Column3 string                `json:"column_3"`
	Column4 int64                 `json:"column_4"`
	Column5 time.Time             `json:"column_5"`
	Column6 time.Time             `json:"column_6"`
	Column7 string                `json:"column_7"`
	Column8 int64                 `json:"column_8"`
	Column9 string                `json:"column_9"`
}

func (q *Queries) CountInventoryTransactions(ctx context.Context, arg CountInventoryTransactionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countInventoryTransactions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO inventory_items (
    name, 
    item_type, 
    description, 
    usage_instructions, 
    dosage, 
    frequency, 
    duration, 
    side_effects, 
    expiration_date, 
    quantity, 
    unit_price, 
    reorder_level, 
    supplier_id, 
    for_species, 
    requires_prescription, 
    storage_condition, 
    batch_number, 
    manufacturer, 
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
) RETURNING id, name, item_type, description, usage_instructions, dosage, frequency, duration, side_effects, expiration_date, quantity, unit_price, reorder_level, supplier_id, for_species, requires_prescription, storage_condition, batch_number, manufacturer, is_active, created_at, updated_at
`

type CreateInventoryItemParams struct {
	Name                 string                `json:"name"`
	ItemType             InventoryItemTypeEnum `json:"item_type"`
	Description          pgtype.Text           `json:"description"`
	UsageInstructions    pgtype.Text           `json:"usage_instructions"`
	Dosage               pgtype.Text           `json:"dosage"`
	Frequency            pgtype.Text           `json:"frequency"`
	Duration             pgtype.Text           `json:"duration"`
	SideEffects          pgtype.Text           `json:"side_effects"`
	ExpirationDate       pgtype.Date           `json:"expiration_date"`
	Quantity             int32                 `json:"quantity"`
	UnitPrice            pgtype.Numeric        `json:"unit_price"`
	ReorderLevel         int32                 `json:"reorder_level"`
	SupplierID           pgtype.Int8           `json:"supplier_id"`
	ForSpecies           pgtype.Text           `json:"for_species"`
	RequiresPrescription pgtype.Bool           `json:"requires_prescription"`
	StorageCondition     pgtype.Text           `json:"storage_condition"`
	BatchNumber          pgtype.Text           `json:"batch_number"`
	Manufacturer         pgtype.Text           `json:"manufacturer"`
	IsActive             pgtype.Bool           `json:"is_active"`
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (InventoryItem, error) {
	row := q.db.QueryRow(ctx, createInventoryItem,
		arg.Name,
		arg.ItemType,
		arg.Description,
		arg.UsageInstructions,
		arg.Dosage,
		arg.Frequency,
		arg.Duration,
		arg.SideEffects,
		arg.ExpirationDate,
		arg.Quantity,
		arg.UnitPrice,
		arg.ReorderLevel,
		arg.SupplierID,
		arg.ForSpecies,
		arg.RequiresPrescription,
		arg.StorageCondition,
		arg.BatchNumber,
		arg.Manufacturer,
		arg.IsActive,
	)
	var i InventoryItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ItemType,
		&i.Description,
		&i.UsageInstructions,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.SideEffects,
		&i.ExpirationDate,
		&i.Quantity,
		&i.UnitPrice,
		&i.ReorderLevel,
		&i.SupplierID,
		&i.ForSpecies,
		&i.RequiresPrescription,
		&i.StorageCondition,
		&i.BatchNumber,
		&i.Manufacturer,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInventoryTransaction = `-- name: CreateInventoryTransaction :one
INSERT INTO inventory_transactions (
    inventory_item_id,
    transaction_type,
    quantity,
    unit_price,
    total_amount,
    transaction_date,
    supplier_id,
    expiration_date,
    batch_number,
    reference_id,
    reference_type,
    notes,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, inventory_item_id, transaction_type, quantity, unit_price, total_amount, transaction_date, supplier_id, expiration_date, batch_number, reference_id, reference_type, notes, created_by, created_at
`

type CreateInventoryTransactionParams struct {
	InventoryItemID int64              `json:"inventory_item_id"`
	TransactionType string             `json:"transaction_type"`
	Quantity        int32              `json:"quantity"`
	UnitPrice       pgtype.Numeric     `json:"unit_price"`
	TotalAmount     pgtype.Numeric     `json:"total_amount"`
	TransactionDate pgtype.Timestamptz `json:"transaction_date"`
	SupplierID      pgtype.Int8        `json:"supplier_id"`
	ExpirationDate  pgtype.Date        `json:"expiration_date"`
	BatchNumber     pgtype.Text        `json:"batch_number"`
	ReferenceID     pgtype.Int8        `json:"reference_id"`
	ReferenceType   pgtype.Text        `json:"reference_type"`
	Notes           pgtype.Text        `json:"notes"`
	CreatedBy       pgtype.Text        `json:"created_by"`
}

// Transaction management
func (q *Queries) CreateInventoryTransaction(ctx context.Context, arg CreateInventoryTransactionParams) (InventoryTransaction, error) {
	row := q.db.QueryRow(ctx, createInventoryTransaction,
		arg.InventoryItemID,
		arg.TransactionType,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalAmount,
		arg.TransactionDate,
		arg.SupplierID,
		arg.ExpirationDate,
		arg.BatchNumber,
		arg.ReferenceID,
		arg.ReferenceType,
		arg.Notes,
		arg.CreatedBy,
	)
	var i InventoryTransaction
	err := row.Scan(
		&i.ID,
		&i.InventoryItemID,
		&i.TransactionType,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalAmount,
		&i.TransactionDate,
		&i.SupplierID,
		&i.ExpirationDate,
		&i.BatchNumber,
		&i.ReferenceID,
		&i.ReferenceType,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deleteInventoryItem = `-- name: DeleteInventoryItem :exec
UPDATE inventory_items SET
    is_active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteInventoryItem(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteInventoryItem, id)
	return err
}

const getExpiringItems = `-- name: GetExpiringItems :many
SELECT 
    i.id, i.name, i.item_type, i.description, i.usage_instructions, i.dosage, i.frequency, i.duration, i.side_effects, i.expiration_date, i.quantity, i.unit_price, i.reorder_level, i.supplier_id, i.for_species, i.requires_prescription, i.storage_condition, i.batch_number, i.manufacturer, i.is_active, i.created_at, i.updated_at,
    s.name as supplier_name,
    (i.quantity <= i.reorder_level) as needs_reorder,
    (i.expiration_date IS NOT NULL AND i.expiration_date < CURRENT_DATE) as is_expired,
    EXTRACT(DAY FROM (i.expiration_date::timestamp - CURRENT_DATE::timestamp)) as days_until_expiry
FROM 
    inventory_items i
LEFT JOIN 
    medicine_suppliers s ON i.supplier_id = s.id
WHERE 
    i.expiration_date IS NOT NULL
    AND i.expiration_date <= (CURRENT_DATE + $1::integer)
    AND i.is_active = true
    AND i.quantity > 0
ORDER BY 
    i.expiration_date ASC
LIMIT $2
OFFSET $3
`

type GetExpiringItemsParams struct {
	Column1 int32 `json:"column_1"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type GetExpiringItemsRow struct {
	ID                   int64                 `json:"id"`
	Name                 string                `json:"name"`
	ItemType             InventoryItemTypeEnum `json:"item_type"`
	Description          pgtype.Text           `json:"description"`
	UsageInstructions    pgtype.Text           `json:"usage_instructions"`
	Dosage               pgtype.Text           `json:"dosage"`
	Frequency            pgtype.Text           `json:"frequency"`
	Duration             pgtype.Text           `json:"duration"`
	SideEffects          pgtype.Text           `json:"side_effects"`
	ExpirationDate       pgtype.Date           `json:"expiration_date"`
	Quantity             int32                 `json:"quantity"`
	UnitPrice            pgtype.Numeric        `json:"unit_price"`
	ReorderLevel         int32                 `json:"reorder_level"`
	SupplierID           pgtype.Int8           `json:"supplier_id"`
	ForSpecies           pgtype.Text           `json:"for_species"`
	RequiresPrescription pgtype.Bool           `json:"requires_prescription"`
	StorageCondition     pgtype.Text           `json:"storage_condition"`
	BatchNumber          pgtype.Text           `json:"batch_number"`
	Manufacturer         pgtype.Text           `json:"manufacturer"`
	IsActive             pgtype.Bool           `json:"is_active"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	SupplierName         pgtype.Text           `json:"supplier_name"`
	NeedsReorder         bool                  `json:"needs_reorder"`
	IsExpired            pgtype.Bool           `json:"is_expired"`
	DaysUntilExpiry      pgtype.Numeric        `json:"days_until_expiry"`
}

func (q *Queries) GetExpiringItems(ctx context.Context, arg GetExpiringItemsParams) ([]GetExpiringItemsRow, error) {
	rows, err := q.db.Query(ctx, getExpiringItems, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExpiringItemsRow{}
	for rows.Next() {
		var i GetExpiringItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ItemType,
			&i.Description,
			&i.UsageInstructions,
			&i.Dosage,
			&i.Frequency,
			&i.Duration,
			&i.SideEffects,
			&i.ExpirationDate,
			&i.Quantity,
			&i.UnitPrice,
			&i.ReorderLevel,
			&i.SupplierID,
			&i.ForSpecies,
			&i.RequiresPrescription,
			&i.StorageCondition,
			&i.BatchNumber,
			&i.Manufacturer,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupplierName,
			&i.NeedsReorder,
			&i.IsExpired,
			&i.DaysUntilExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryItem = `-- name: GetInventoryItem :one
SELECT 
    i.id, i.name, i.item_type, i.description, i.usage_instructions, i.dosage, i.frequency, i.duration, i.side_effects, i.expiration_date, i.quantity, i.unit_price, i.reorder_level, i.supplier_id, i.for_species, i.requires_prescription, i.storage_condition, i.batch_number, i.manufacturer, i.is_active, i.created_at, i.updated_at,
    s.name as supplier_name,
    (i.quantity <= i.reorder_level) as needs_reorder,
    (i.expiration_date IS NOT NULL AND i.expiration_date < CURRENT_DATE) as is_expired
FROM 
    inventory_items i
LEFT JOIN 
    medicine_suppliers s ON i.supplier_id = s.id
WHERE 
    i.id = $1
`

type GetInventoryItemRow struct {
	ID                   int64                 `json:"id"`
	Name                 string                `json:"name"`
	ItemType             InventoryItemTypeEnum `json:"item_type"`
	Description          pgtype.Text           `json:"description"`
	UsageInstructions    pgtype.Text           `json:"usage_instructions"`
	Dosage               pgtype.Text           `json:"dosage"`
	Frequency            pgtype.Text           `json:"frequency"`
	Duration             pgtype.Text           `json:"duration"`
	SideEffects          pgtype.Text           `json:"side_effects"`
	ExpirationDate       pgtype.Date           `json:"expiration_date"`
	Quantity             int32                 `json:"quantity"`
	UnitPrice            pgtype.Numeric        `json:"unit_price"`
	ReorderLevel         int32                 `json:"reorder_level"`
	SupplierID           pgtype.Int8           `json:"supplier_id"`
	ForSpecies           pgtype.Text           `json:"for_species"`
	RequiresPrescription pgtype.Bool           `json:"requires_prescription"`
	StorageCondition     pgtype.Text           `json:"storage_condition"`
	BatchNumber          pgtype.Text           `json:"batch_number"`
	Manufacturer         pgtype.Text           `json:"manufacturer"`
	IsActive             pgtype.Bool           `json:"is_active"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	SupplierName         pgtype.Text           `json:"supplier_name"`
	NeedsReorder         bool                  `json:"needs_reorder"`
	IsExpired            pgtype.Bool           `json:"is_expired"`
}

func (q *Queries) GetInventoryItem(ctx context.Context, id int64) (GetInventoryItemRow, error) {
	row := q.db.QueryRow(ctx, getInventoryItem, id)
	var i GetInventoryItemRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ItemType,
		&i.Description,
		&i.UsageInstructions,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.SideEffects,
		&i.ExpirationDate,
		&i.Quantity,
		&i.UnitPrice,
		&i.ReorderLevel,
		&i.SupplierID,
		&i.ForSpecies,
		&i.RequiresPrescription,
		&i.StorageCondition,
		&i.BatchNumber,
		&i.Manufacturer,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SupplierName,
		&i.NeedsReorder,
		&i.IsExpired,
	)
	return i, err
}

const getInventoryItemsByType = `-- name: GetInventoryItemsByType :many
SELECT 
    i.id, i.name, i.item_type, i.description, i.usage_instructions, i.dosage, i.frequency, i.duration, i.side_effects, i.expiration_date, i.quantity, i.unit_price, i.reorder_level, i.supplier_id, i.for_species, i.requires_prescription, i.storage_condition, i.batch_number, i.manufacturer, i.is_active, i.created_at, i.updated_at,
    s.name as supplier_name,
    (i.quantity <= i.reorder_level) as needs_reorder,
    (i.expiration_date IS NOT NULL AND i.expiration_date < CURRENT_DATE) as is_expired
FROM 
    inventory_items i
LEFT JOIN 
    medicine_suppliers s ON i.supplier_id = s.id
WHERE 
    i.item_type = $1
    AND i.is_active = true
ORDER BY 
    i.name
LIMIT $2
OFFSET $3
`

type GetInventoryItemsByTypeParams struct {
	ItemType InventoryItemTypeEnum `json:"item_type"`
	Limit    int32                 `json:"limit"`
	Offset   int32                 `json:"offset"`
}

type GetInventoryItemsByTypeRow struct {
	ID                   int64                 `json:"id"`
	Name                 string                `json:"name"`
	ItemType             InventoryItemTypeEnum `json:"item_type"`
	Description          pgtype.Text           `json:"description"`
	UsageInstructions    pgtype.Text           `json:"usage_instructions"`
	Dosage               pgtype.Text           `json:"dosage"`
	Frequency            pgtype.Text           `json:"frequency"`
	Duration             pgtype.Text           `json:"duration"`
	SideEffects          pgtype.Text           `json:"side_effects"`
	ExpirationDate       pgtype.Date           `json:"expiration_date"`
	Quantity             int32                 `json:"quantity"`
	UnitPrice            pgtype.Numeric        `json:"unit_price"`
	ReorderLevel         int32                 `json:"reorder_level"`
	SupplierID           pgtype.Int8           `json:"supplier_id"`
	ForSpecies           pgtype.Text           `json:"for_species"`
	RequiresPrescription pgtype.Bool           `json:"requires_prescription"`
	StorageCondition     pgtype.Text           `json:"storage_condition"`
	BatchNumber          pgtype.Text           `json:"batch_number"`
	Manufacturer         pgtype.Text           `json:"manufacturer"`
	IsActive             pgtype.Bool           `json:"is_active"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	SupplierName         pgtype.Text           `json:"supplier_name"`
	NeedsReorder         bool                  `json:"needs_reorder"`
	IsExpired            pgtype.Bool           `json:"is_expired"`
}

func (q *Queries) GetInventoryItemsByType(ctx context.Context, arg GetInventoryItemsByTypeParams) ([]GetInventoryItemsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getInventoryItemsByType, arg.ItemType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInventoryItemsByTypeRow{}
	for rows.Next() {
		var i GetInventoryItemsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ItemType,
			&i.Description,
			&i.UsageInstructions,
			&i.Dosage,
			&i.Frequency,
			&i.Duration,
			&i.SideEffects,
			&i.ExpirationDate,
			&i.Quantity,
			&i.UnitPrice,
			&i.ReorderLevel,
			&i.SupplierID,
			&i.ForSpecies,
			&i.RequiresPrescription,
			&i.StorageCondition,
			&i.BatchNumber,
			&i.Manufacturer,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupplierName,
			&i.NeedsReorder,
			&i.IsExpired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventorySummary = `-- name: GetInventorySummary :many
SELECT 
    i.id, 
    i.name, 
    i.item_type, 
    i.quantity, 
    i.unit_price, 
    (i.quantity * i.unit_price) as total_value,
    i.is_active,
    (i.quantity <= i.reorder_level) as needs_reorder
FROM 
    inventory_items i
WHERE 
    ($1::inventory_item_type_enum IS NULL OR i.item_type = $1)
    AND i.is_active = true
ORDER BY 
    i.name
`

type GetInventorySummaryRow struct {
	ID           int64                 `json:"id"`
	Name         string                `json:"name"`
	ItemType     InventoryItemTypeEnum `json:"item_type"`
	Quantity     int32                 `json:"quantity"`
	UnitPrice    pgtype.Numeric        `json:"unit_price"`
	TotalValue   int32                 `json:"total_value"`
	IsActive     pgtype.Bool           `json:"is_active"`
	NeedsReorder bool                  `json:"needs_reorder"`
}

func (q *Queries) GetInventorySummary(ctx context.Context, dollar_1 InventoryItemTypeEnum) ([]GetInventorySummaryRow, error) {
	rows, err := q.db.Query(ctx, getInventorySummary, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInventorySummaryRow{}
	for rows.Next() {
		var i GetInventorySummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ItemType,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalValue,
			&i.IsActive,
			&i.NeedsReorder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryTransaction = `-- name: GetInventoryTransaction :one
SELECT 
    t.id, t.inventory_item_id, t.transaction_type, t.quantity, t.unit_price, t.total_amount, t.transaction_date, t.supplier_id, t.expiration_date, t.batch_number, t.reference_id, t.reference_type, t.notes, t.created_by, t.created_at,
    i.name,
    i.item_type,
    s.name as supplier_name
FROM 
    inventory_transactions t
JOIN 
    inventory_items i ON t.inventory_item_id = i.id
LEFT JOIN 
    medicine_suppliers s ON t.supplier_id = s.id
WHERE 
    t.id = $1
`

type GetInventoryTransactionRow struct {
	ID              int64                 `json:"id"`
	InventoryItemID int64                 `json:"inventory_item_id"`
	TransactionType string                `json:"transaction_type"`
	Quantity        int32                 `json:"quantity"`
	UnitPrice       pgtype.Numeric        `json:"unit_price"`
	TotalAmount     pgtype.Numeric        `json:"total_amount"`
	TransactionDate pgtype.Timestamptz    `json:"transaction_date"`
	SupplierID      pgtype.Int8           `json:"supplier_id"`
	ExpirationDate  pgtype.Date           `json:"expiration_date"`
	BatchNumber     pgtype.Text           `json:"batch_number"`
	ReferenceID     pgtype.Int8           `json:"reference_id"`
	ReferenceType   pgtype.Text           `json:"reference_type"`
	Notes           pgtype.Text           `json:"notes"`
	CreatedBy       pgtype.Text           `json:"created_by"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	Name            string                `json:"name"`
	ItemType        InventoryItemTypeEnum `json:"item_type"`
	SupplierName    pgtype.Text           `json:"supplier_name"`
}

func (q *Queries) GetInventoryTransaction(ctx context.Context, id int64) (GetInventoryTransactionRow, error) {
	row := q.db.QueryRow(ctx, getInventoryTransaction, id)
	var i GetInventoryTransactionRow
	err := row.Scan(
		&i.ID,
		&i.InventoryItemID,
		&i.TransactionType,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalAmount,
		&i.TransactionDate,
		&i.SupplierID,
		&i.ExpirationDate,
		&i.BatchNumber,
		&i.ReferenceID,
		&i.ReferenceType,
		&i.Notes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Name,
		&i.ItemType,
		&i.SupplierName,
	)
	return i, err
}

const getInventoryTransactionsByItem = `-- name: GetInventoryTransactionsByItem :many
SELECT 
    t.id, t.inventory_item_id, t.transaction_type, t.quantity, t.unit_price, t.total_amount, t.transaction_date, t.supplier_id, t.expiration_date, t.batch_number, t.reference_id, t.reference_type, t.notes, t.created_by, t.created_at,
    i.name,
    i.item_type,
    s.name as supplier_name
FROM 
    inventory_transactions t
JOIN 
    inventory_items i ON t.inventory_item_id = i.id
LEFT JOIN 
    medicine_suppliers s ON t.supplier_id = s.id
WHERE 
    t.inventory_item_id = $1
ORDER BY 
    t.transaction_date DESC
LIMIT $2
OFFSET $3
`

type GetInventoryTransactionsByItemParams struct {
	InventoryItemID int64 `json:"inventory_item_id"`
	Limit           int32 `json:"limit"`
	Offset          int32 `json:"offset"`
}

type GetInventoryTransactionsByItemRow struct {
	ID              int64                 `json:"id"`
	InventoryItemID int64                 `json:"inventory_item_id"`
	TransactionType string                `json:"transaction_type"`
	Quantity        int32                 `json:"quantity"`
	UnitPrice       pgtype.Numeric        `json:"unit_price"`
	TotalAmount     pgtype.Numeric        `json:"total_amount"`
	TransactionDate pgtype.Timestamptz    `json:"transaction_date"`
	SupplierID      pgtype.Int8           `json:"supplier_id"`
	ExpirationDate  pgtype.Date           `json:"expiration_date"`
	BatchNumber     pgtype.Text           `json:"batch_number"`
	ReferenceID     pgtype.Int8           `json:"reference_id"`
	ReferenceType   pgtype.Text           `json:"reference_type"`
	Notes           pgtype.Text           `json:"notes"`
	CreatedBy       pgtype.Text           `json:"created_by"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	Name            string                `json:"name"`
	ItemType        InventoryItemTypeEnum `json:"item_type"`
	SupplierName    pgtype.Text           `json:"supplier_name"`
}

func (q *Queries) GetInventoryTransactionsByItem(ctx context.Context, arg GetInventoryTransactionsByItemParams) ([]GetInventoryTransactionsByItemRow, error) {
	rows, err := q.db.Query(ctx, getInventoryTransactionsByItem, arg.InventoryItemID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInventoryTransactionsByItemRow{}
	for rows.Next() {
		var i GetInventoryTransactionsByItemRow
		if err := rows.Scan(
			&i.ID,
			&i.InventoryItemID,
			&i.TransactionType,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalAmount,
			&i.TransactionDate,
			&i.SupplierID,
			&i.ExpirationDate,
			&i.BatchNumber,
			&i.ReferenceID,
			&i.ReferenceType,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Name,
			&i.ItemType,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryTransactionsSummary = `-- name: GetInventoryTransactionsSummary :many
SELECT 
    t.transaction_type,
    SUM(t.quantity) as total_quantity,
    SUM(COALESCE(t.total_amount, 0)) as total_value,
    COUNT(*) as transaction_count
FROM 
    inventory_transactions t
JOIN 
    inventory_items i ON t.inventory_item_id = i.id
WHERE 
    t.transaction_date BETWEEN $1 AND $2
    AND ($3::inventory_item_type_enum IS NULL OR i.item_type = $3)
GROUP BY 
    t.transaction_type
ORDER BY 
    t.transaction_type
`

type GetInventoryTransactionsSummaryParams struct {
	TransactionDate   pgtype.Timestamptz    `json:"transaction_date"`
	TransactionDate_2 pgtype.Timestamptz    `json:"transaction_date_2"`
	Column3           InventoryItemTypeEnum `json:"column_3"`
}

type GetInventoryTransactionsSummaryRow struct {
	TransactionType  string `json:"transaction_type"`
	TotalQuantity    int64  `json:"total_quantity"`
	TotalValue       int64  `json:"total_value"`
	TransactionCount int64  `json:"transaction_count"`
}

func (q *Queries) GetInventoryTransactionsSummary(ctx context.Context, arg GetInventoryTransactionsSummaryParams) ([]GetInventoryTransactionsSummaryRow, error) {
	rows, err := q.db.Query(ctx, getInventoryTransactionsSummary, arg.TransactionDate, arg.TransactionDate_2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInventoryTransactionsSummaryRow{}
	for rows.Next() {
		var i GetInventoryTransactionsSummaryRow
		if err := rows.Scan(
			&i.TransactionType,
			&i.TotalQuantity,
			&i.TotalValue,
			&i.TransactionCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockItems = `-- name: GetLowStockItems :many
SELECT 
    i.id, i.name, i.item_type, i.description, i.usage_instructions, i.dosage, i.frequency, i.duration, i.side_effects, i.expiration_date, i.quantity, i.unit_price, i.reorder_level, i.supplier_id, i.for_species, i.requires_prescription, i.storage_condition, i.batch_number, i.manufacturer, i.is_active, i.created_at, i.updated_at,
    s.name as supplier_name,
    (i.quantity <= i.reorder_level) as needs_reorder,
    (i.expiration_date IS NOT NULL AND i.expiration_date < CURRENT_DATE) as is_expired
FROM 
    inventory_items i
LEFT JOIN 
    medicine_suppliers s ON i.supplier_id = s.id
WHERE 
    i.quantity <= i.reorder_level
    AND i.is_active = true
ORDER BY 
    i.quantity ASC
LIMIT $1
OFFSET $2
`

type GetLowStockItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetLowStockItemsRow struct {
	ID                   int64                 `json:"id"`
	Name                 string                `json:"name"`
	ItemType             InventoryItemTypeEnum `json:"item_type"`
	Description          pgtype.Text           `json:"description"`
	UsageInstructions    pgtype.Text           `json:"usage_instructions"`
	Dosage               pgtype.Text           `json:"dosage"`
	Frequency            pgtype.Text           `json:"frequency"`
	Duration             pgtype.Text           `json:"duration"`
	SideEffects          pgtype.Text           `json:"side_effects"`
	ExpirationDate       pgtype.Date           `json:"expiration_date"`
	Quantity             int32                 `json:"quantity"`
	UnitPrice            pgtype.Numeric        `json:"unit_price"`
	ReorderLevel         int32                 `json:"reorder_level"`
	SupplierID           pgtype.Int8           `json:"supplier_id"`
	ForSpecies           pgtype.Text           `json:"for_species"`
	RequiresPrescription pgtype.Bool           `json:"requires_prescription"`
	StorageCondition     pgtype.Text           `json:"storage_condition"`
	BatchNumber          pgtype.Text           `json:"batch_number"`
	Manufacturer         pgtype.Text           `json:"manufacturer"`
	IsActive             pgtype.Bool           `json:"is_active"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	SupplierName         pgtype.Text           `json:"supplier_name"`
	NeedsReorder         bool                  `json:"needs_reorder"`
	IsExpired            pgtype.Bool           `json:"is_expired"`
}

func (q *Queries) GetLowStockItems(ctx context.Context, arg GetLowStockItemsParams) ([]GetLowStockItemsRow, error) {
	rows, err := q.db.Query(ctx, getLowStockItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLowStockItemsRow{}
	for rows.Next() {
		var i GetLowStockItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ItemType,
			&i.Description,
			&i.UsageInstructions,
			&i.Dosage,
			&i.Frequency,
			&i.Duration,
			&i.SideEffects,
			&i.ExpirationDate,
			&i.Quantity,
			&i.UnitPrice,
			&i.ReorderLevel,
			&i.SupplierID,
			&i.ForSpecies,
			&i.RequiresPrescription,
			&i.StorageCondition,
			&i.BatchNumber,
			&i.Manufacturer,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupplierName,
			&i.NeedsReorder,
			&i.IsExpired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryItems = `-- name: ListInventoryItems :many
SELECT 
    i.id, i.name, i.item_type, i.description, i.usage_instructions, i.dosage, i.frequency, i.duration, i.side_effects, i.expiration_date, i.quantity, i.unit_price, i.reorder_level, i.supplier_id, i.for_species, i.requires_prescription, i.storage_condition, i.batch_number, i.manufacturer, i.is_active, i.created_at, i.updated_at,
    s.name as supplier_name,
    (i.quantity <= i.reorder_level) as needs_reorder,
    (i.expiration_date IS NOT NULL AND i.expiration_date < CURRENT_DATE) as is_expired
FROM 
    inventory_items i
LEFT JOIN 
    medicine_suppliers s ON i.supplier_id = s.id
WHERE 
    ($1::inventory_item_type_enum IS NULL OR i.item_type = $1)
    AND ($2::text IS NULL OR i.name ILIKE '%' || $2 || '%')
    AND ($3::boolean IS NULL OR i.is_active = $3)
    AND ($4::boolean IS NULL OR (i.quantity <= i.reorder_level) = $4)
    AND ($5::boolean IS NULL OR (i.expiration_date IS NOT NULL AND i.expiration_date < CURRENT_DATE) = $5)
    AND ($6::bigint IS NULL OR i.supplier_id = $6)
    AND ($7::text IS NULL OR i.for_species = $7)
    AND ($8::boolean IS NULL OR i.requires_prescription = $8)
ORDER BY 
    i.name
LIMIT $9
OFFSET $10
`

type ListInventoryItemsParams struct {
	Column1 InventoryItemTypeEnum `json:"column_1"`
	Column2 string                `json:"column_2"`
	Column3 bool                  `json:"column_3"`
	Column4 bool                  `json:"column_4"`
	Column5 bool                  `json:"column_5"`
	Column6 int64                 `json:"column_6"`
	Column7 string                `json:"column_7"`
	Column8 bool                  `json:"column_8"`
	Limit   int32                 `json:"limit"`
	Offset  int32                 `json:"offset"`
}

type ListInventoryItemsRow struct {
	ID                   int64                 `json:"id"`
	Name                 string                `json:"name"`
	ItemType             InventoryItemTypeEnum `json:"item_type"`
	Description          pgtype.Text           `json:"description"`
	UsageInstructions    pgtype.Text           `json:"usage_instructions"`
	Dosage               pgtype.Text           `json:"dosage"`
	Frequency            pgtype.Text           `json:"frequency"`
	Duration             pgtype.Text           `json:"duration"`
	SideEffects          pgtype.Text           `json:"side_effects"`
	ExpirationDate       pgtype.Date           `json:"expiration_date"`
	Quantity             int32                 `json:"quantity"`
	UnitPrice            pgtype.Numeric        `json:"unit_price"`
	ReorderLevel         int32                 `json:"reorder_level"`
	SupplierID           pgtype.Int8           `json:"supplier_id"`
	ForSpecies           pgtype.Text           `json:"for_species"`
	RequiresPrescription pgtype.Bool           `json:"requires_prescription"`
	StorageCondition     pgtype.Text           `json:"storage_condition"`
	BatchNumber          pgtype.Text           `json:"batch_number"`
	Manufacturer         pgtype.Text           `json:"manufacturer"`
	IsActive             pgtype.Bool           `json:"is_active"`
	CreatedAt            pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz    `json:"updated_at"`
	SupplierName         pgtype.Text           `json:"supplier_name"`
	NeedsReorder         bool                  `json:"needs_reorder"`
	IsExpired            pgtype.Bool           `json:"is_expired"`
}

func (q *Queries) ListInventoryItems(ctx context.Context, arg ListInventoryItemsParams) ([]ListInventoryItemsRow, error) {
	rows, err := q.db.Query(ctx, listInventoryItems,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInventoryItemsRow{}
	for rows.Next() {
		var i ListInventoryItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ItemType,
			&i.Description,
			&i.UsageInstructions,
			&i.Dosage,
			&i.Frequency,
			&i.Duration,
			&i.SideEffects,
			&i.ExpirationDate,
			&i.Quantity,
			&i.UnitPrice,
			&i.ReorderLevel,
			&i.SupplierID,
			&i.ForSpecies,
			&i.RequiresPrescription,
			&i.StorageCondition,
			&i.BatchNumber,
			&i.Manufacturer,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SupplierName,
			&i.NeedsReorder,
			&i.IsExpired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryTransactions = `-- name: ListInventoryTransactions :many
SELECT 
    t.id, t.inventory_item_id, t.transaction_type, t.quantity, t.unit_price, t.total_amount, t.transaction_date, t.supplier_id, t.expiration_date, t.batch_number, t.reference_id, t.reference_type, t.notes, t.created_by, t.created_at,
    i.name,
    i.item_type,
    s.name as supplier_name
FROM 
    inventory_transactions t
JOIN 
    inventory_items i ON t.inventory_item_id = i.id
LEFT JOIN 
    medicine_suppliers s ON t.supplier_id = s.id
WHERE 
    ($1::bigint IS NULL OR t.inventory_item_id = $1)
    AND ($2::inventory_item_type_enum IS NULL OR i.item_type = $2)
    AND ($3::text IS NULL OR t.transaction_type = $3)
    AND ($4::bigint IS NULL OR t.supplier_id = $4)
    AND ($5::timestamptz IS NULL OR t.transaction_date >= $5)
    AND ($6::timestamptz IS NULL OR t.transaction_date <= $6)
    AND ($7::text IS NULL OR t.reference_type = $7)
    AND ($8::bigint IS NULL OR t.reference_id = $8)
    AND ($9::text IS NULL OR t.created_by = $9)
ORDER BY 
    t.transaction_date DESC
LIMIT $10
OFFSET $11
`

type ListInventoryTransactionsParams struct {
	Column1 int64                 `json:"column_1"`
	Column2 InventoryItemTypeEnum `json:"column_2"`
	Column3 string                `json:"column_3"`
	Column4 int64                 `json:"column_4"`
	Column5 time.Time             `json:"column_5"`
	Column6 time.Time             `json:"column_6"`
	Column7 string                `json:"column_7"`
	Column8 int64                 `json:"column_8"`
	Column9 string                `json:"column_9"`
	Limit   int32                 `json:"limit"`
	Offset  int32                 `json:"offset"`
}

type ListInventoryTransactionsRow struct {
	ID              int64                 `json:"id"`
	InventoryItemID int64                 `json:"inventory_item_id"`
	TransactionType string                `json:"transaction_type"`
	Quantity        int32                 `json:"quantity"`
	UnitPrice       pgtype.Numeric        `json:"unit_price"`
	TotalAmount     pgtype.Numeric        `json:"total_amount"`
	TransactionDate pgtype.Timestamptz    `json:"transaction_date"`
	SupplierID      pgtype.Int8           `json:"supplier_id"`
	ExpirationDate  pgtype.Date           `json:"expiration_date"`
	BatchNumber     pgtype.Text           `json:"batch_number"`
	ReferenceID     pgtype.Int8           `json:"reference_id"`
	ReferenceType   pgtype.Text           `json:"reference_type"`
	Notes           pgtype.Text           `json:"notes"`
	CreatedBy       pgtype.Text           `json:"created_by"`
	CreatedAt       pgtype.Timestamptz    `json:"created_at"`
	Name            string                `json:"name"`
	ItemType        InventoryItemTypeEnum `json:"item_type"`
	SupplierName    pgtype.Text           `json:"supplier_name"`
}

func (q *Queries) ListInventoryTransactions(ctx context.Context, arg ListInventoryTransactionsParams) ([]ListInventoryTransactionsRow, error) {
	rows, err := q.db.Query(ctx, listInventoryTransactions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInventoryTransactionsRow{}
	for rows.Next() {
		var i ListInventoryTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.InventoryItemID,
			&i.TransactionType,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalAmount,
			&i.TransactionDate,
			&i.SupplierID,
			&i.ExpirationDate,
			&i.BatchNumber,
			&i.ReferenceID,
			&i.ReferenceType,
			&i.Notes,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Name,
			&i.ItemType,
			&i.SupplierName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryItem = `-- name: UpdateInventoryItem :exec
UPDATE inventory_items SET
    name = $1,
    item_type = $2,
    description = $3,
    usage_instructions = $4,
    dosage = $5,
    frequency = $6,
    duration = $7,
    side_effects = $8,
    expiration_date = $9,
    quantity = $10,
    unit_price = $11,
    reorder_level = $12,
    supplier_id = $13,
    for_species = $14,
    requires_prescription = $15,
    storage_condition = $16,
    batch_number = $17,
    manufacturer = $18,
    is_active = $19,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $20
`

type UpdateInventoryItemParams struct {
	Name                 string                `json:"name"`
	ItemType             InventoryItemTypeEnum `json:"item_type"`
	Description          pgtype.Text           `json:"description"`
	UsageInstructions    pgtype.Text           `json:"usage_instructions"`
	Dosage               pgtype.Text           `json:"dosage"`
	Frequency            pgtype.Text           `json:"frequency"`
	Duration             pgtype.Text           `json:"duration"`
	SideEffects          pgtype.Text           `json:"side_effects"`
	ExpirationDate       pgtype.Date           `json:"expiration_date"`
	Quantity             int32                 `json:"quantity"`
	UnitPrice            pgtype.Numeric        `json:"unit_price"`
	ReorderLevel         int32                 `json:"reorder_level"`
	SupplierID           pgtype.Int8           `json:"supplier_id"`
	ForSpecies           pgtype.Text           `json:"for_species"`
	RequiresPrescription pgtype.Bool           `json:"requires_prescription"`
	StorageCondition     pgtype.Text           `json:"storage_condition"`
	BatchNumber          pgtype.Text           `json:"batch_number"`
	Manufacturer         pgtype.Text           `json:"manufacturer"`
	IsActive             pgtype.Bool           `json:"is_active"`
	ID                   int64                 `json:"id"`
}

func (q *Queries) UpdateInventoryItem(ctx context.Context, arg UpdateInventoryItemParams) error {
	_, err := q.db.Exec(ctx, updateInventoryItem,
		arg.Name,
		arg.ItemType,
		arg.Description,
		arg.UsageInstructions,
		arg.Dosage,
		arg.Frequency,
		arg.Duration,
		arg.SideEffects,
		arg.ExpirationDate,
		arg.Quantity,
		arg.UnitPrice,
		arg.ReorderLevel,
		arg.SupplierID,
		arg.ForSpecies,
		arg.RequiresPrescription,
		arg.StorageCondition,
		arg.BatchNumber,
		arg.Manufacturer,
		arg.IsActive,
		arg.ID,
	)
	return err
}
