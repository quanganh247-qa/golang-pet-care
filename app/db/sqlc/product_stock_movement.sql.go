// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: product_stock_movement.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProductStockMovement = `-- name: CreateProductStockMovement :one
INSERT INTO product_stock_movements (
    product_id,
    movement_type,
    quantity,
    reason,
    price -- Add price column
)
VALUES (
    $1, $2, $3, $4, $5 -- Add price parameter
)
RETURNING movement_id, product_id, movement_type, quantity, reason, movement_date, price
`

type CreateProductStockMovementParams struct {
	ProductID    int64            `json:"product_id"`
	MovementType MovementTypeEnum `json:"movement_type"`
	Quantity     int32            `json:"quantity"`
	Reason       pgtype.Text      `json:"reason"`
	Price        pgtype.Numeric   `json:"price"`
}

func (q *Queries) CreateProductStockMovement(ctx context.Context, arg CreateProductStockMovementParams) (ProductStockMovement, error) {
	row := q.db.QueryRow(ctx, createProductStockMovement,
		arg.ProductID,
		arg.MovementType,
		arg.Quantity,
		arg.Reason,
		arg.Price,
	)
	var i ProductStockMovement
	err := row.Scan(
		&i.MovementID,
		&i.ProductID,
		&i.MovementType,
		&i.Quantity,
		&i.Reason,
		&i.MovementDate,
		&i.Price,
	)
	return i, err
}

const getAllProductStockMovements = `-- name: GetAllProductStockMovements :many
SELECT movement_id, product_id, movement_type, quantity, reason, movement_date, price FROM product_stock_movements
ORDER BY movement_date DESC
LIMIT $1 OFFSET $2
`

type GetAllProductStockMovementsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllProductStockMovements(ctx context.Context, arg GetAllProductStockMovementsParams) ([]ProductStockMovement, error) {
	rows, err := q.db.Query(ctx, getAllProductStockMovements, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockMovement{}
	for rows.Next() {
		var i ProductStockMovement
		if err := rows.Scan(
			&i.MovementID,
			&i.ProductID,
			&i.MovementType,
			&i.Quantity,
			&i.Reason,
			&i.MovementDate,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductStockMovementsByProductID = `-- name: GetProductStockMovementsByProductID :many
SELECT
    movement_id,
    product_id,
    movement_type,
    quantity,
    reason,
    movement_date,
    price -- Select price column
FROM product_stock_movements
WHERE product_id = $1
ORDER BY movement_date DESC
LIMIT $2
OFFSET $3
`

type GetProductStockMovementsByProductIDParams struct {
	ProductID int64 `json:"product_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) GetProductStockMovementsByProductID(ctx context.Context, arg GetProductStockMovementsByProductIDParams) ([]ProductStockMovement, error) {
	rows, err := q.db.Query(ctx, getProductStockMovementsByProductID, arg.ProductID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductStockMovement{}
	for rows.Next() {
		var i ProductStockMovement
		if err := rows.Scan(
			&i.MovementID,
			&i.ProductID,
			&i.MovementType,
			&i.Quantity,
			&i.Reason,
			&i.MovementDate,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalStockMovementsByProductID = `-- name: GetTotalStockMovementsByProductID :one
SELECT
    product_id,
    COALESCE(SUM(CASE WHEN movement_type = 'import' THEN quantity ELSE 0 END), 0) AS total_imported,
    COALESCE(SUM(CASE WHEN movement_type = 'export' THEN quantity ELSE 0 END), 0) AS total_exported
FROM product_stock_movements
WHERE product_id = $1
GROUP BY product_id
`

type GetTotalStockMovementsByProductIDRow struct {
	ProductID     int64       `json:"product_id"`
	TotalImported interface{} `json:"total_imported"`
	TotalExported interface{} `json:"total_exported"`
}

func (q *Queries) GetTotalStockMovementsByProductID(ctx context.Context, productID int64) (GetTotalStockMovementsByProductIDRow, error) {
	row := q.db.QueryRow(ctx, getTotalStockMovementsByProductID, productID)
	var i GetTotalStockMovementsByProductIDRow
	err := row.Scan(&i.ProductID, &i.TotalImported, &i.TotalExported)
	return i, err
}
