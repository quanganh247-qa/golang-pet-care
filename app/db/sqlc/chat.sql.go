// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: chat.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addParticipantToConversation = `-- name: AddParticipantToConversation :one
INSERT INTO conversation_participants (
  conversation_id,
  user_id,
  is_admin
) VALUES (
  $1, $2, $3
) RETURNING conversation_id, user_id, joined_at, left_at, is_admin
`

type AddParticipantToConversationParams struct {
	ConversationID int64 `json:"conversation_id"`
	UserID         int64 `json:"user_id"`
	IsAdmin        bool  `json:"is_admin"`
}

func (q *Queries) AddParticipantToConversation(ctx context.Context, arg AddParticipantToConversationParams) (ConversationParticipant, error) {
	row := q.db.QueryRow(ctx, addParticipantToConversation, arg.ConversationID, arg.UserID, arg.IsAdmin)
	var i ConversationParticipant
	err := row.Scan(
		&i.ConversationID,
		&i.UserID,
		&i.JoinedAt,
		&i.LeftAt,
		&i.IsAdmin,
	)
	return i, err
}

const createConversation = `-- name: CreateConversation :one
INSERT INTO conversations (
  type, 
  name
) VALUES (
  $1, $2
) RETURNING id, type, name, created_at, updated_at
`

type CreateConversationParams struct {
	Type string      `json:"type"`
	Name pgtype.Text `json:"name"`
}

func (q *Queries) CreateConversation(ctx context.Context, arg CreateConversationParams) (Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation, arg.Type, arg.Name)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
  conversation_id,
  sender_id,
  content,
  message_type,
  metadata
) VALUES (
  $1, $2, $3, $4, $5
) RETURNING id, conversation_id, sender_id, content, message_type, metadata, created_at, updated_at
`

type CreateMessageParams struct {
	ConversationID int64  `json:"conversation_id"`
	SenderID       int64  `json:"sender_id"`
	Content        string `json:"content"`
	MessageType    string `json:"message_type"`
	Metadata       []byte `json:"metadata"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ConversationID,
		arg.SenderID,
		arg.Content,
		arg.MessageType,
		arg.Metadata,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversation = `-- name: GetConversation :one
SELECT id, type, name, created_at, updated_at FROM conversations
WHERE id = $1
`

func (q *Queries) GetConversation(ctx context.Context, id int64) (Conversation, error) {
	row := q.db.QueryRow(ctx, getConversation, id)
	var i Conversation
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConversationLastMessage = `-- name: GetConversationLastMessage :one
SELECT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.metadata, m.created_at, m.updated_at, u.username as sender_username, u.full_name as sender_name
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.conversation_id = $1
ORDER BY m.created_at DESC
LIMIT 1
`

type GetConversationLastMessageRow struct {
	ID             int64            `json:"id"`
	ConversationID int64            `json:"conversation_id"`
	SenderID       int64            `json:"sender_id"`
	Content        string           `json:"content"`
	MessageType    string           `json:"message_type"`
	Metadata       []byte           `json:"metadata"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	SenderUsername string           `json:"sender_username"`
	SenderName     string           `json:"sender_name"`
}

func (q *Queries) GetConversationLastMessage(ctx context.Context, conversationID int64) (GetConversationLastMessageRow, error) {
	row := q.db.QueryRow(ctx, getConversationLastMessage, conversationID)
	var i GetConversationLastMessageRow
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SenderUsername,
		&i.SenderName,
	)
	return i, err
}

const getConversationParticipants = `-- name: GetConversationParticipants :many
SELECT u.id, u.username, u.email, u.full_name, cp.is_admin, cp.joined_at
FROM conversation_participants cp
JOIN users u ON cp.user_id = u.id
WHERE cp.conversation_id = $1 AND cp.left_at IS NULL
`

type GetConversationParticipantsRow struct {
	ID       int64            `json:"id"`
	Username string           `json:"username"`
	Email    string           `json:"email"`
	FullName string           `json:"full_name"`
	IsAdmin  bool             `json:"is_admin"`
	JoinedAt pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetConversationParticipants(ctx context.Context, conversationID int64) ([]GetConversationParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getConversationParticipants, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConversationParticipantsRow{}
	for rows.Next() {
		var i GetConversationParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.FullName,
			&i.IsAdmin,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByConversation = `-- name: GetMessagesByConversation :many
SELECT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.metadata, m.created_at, m.updated_at, u.username as sender_username, u.full_name as sender_name
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.conversation_id = $1
ORDER BY m.created_at
LIMIT $2
OFFSET $3
`

type GetMessagesByConversationParams struct {
	ConversationID int64 `json:"conversation_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type GetMessagesByConversationRow struct {
	ID             int64            `json:"id"`
	ConversationID int64            `json:"conversation_id"`
	SenderID       int64            `json:"sender_id"`
	Content        string           `json:"content"`
	MessageType    string           `json:"message_type"`
	Metadata       []byte           `json:"metadata"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	SenderUsername string           `json:"sender_username"`
	SenderName     string           `json:"sender_name"`
}

func (q *Queries) GetMessagesByConversation(ctx context.Context, arg GetMessagesByConversationParams) ([]GetMessagesByConversationRow, error) {
	rows, err := q.db.Query(ctx, getMessagesByConversation, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByConversationRow{}
	for rows.Next() {
		var i GetMessagesByConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadMessageCount = `-- name: GetUnreadMessageCount :one
SELECT COUNT(*) 
FROM messages m
LEFT JOIN message_read_status mrs ON m.id = mrs.message_id AND mrs.user_id = $2
WHERE m.conversation_id = $1 
AND mrs.message_id IS NULL
AND m.sender_id != $2
`

type GetUnreadMessageCountParams struct {
	ConversationID int64 `json:"conversation_id"`
	UserID         int64 `json:"user_id"`
}

func (q *Queries) GetUnreadMessageCount(ctx context.Context, arg GetUnreadMessageCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUnreadMessageCount, arg.ConversationID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT c.id, c.type, c.name, c.created_at, c.updated_at 
FROM conversations c
JOIN conversation_participants cp ON c.id = cp.conversation_id
WHERE cp.user_id = $1 AND cp.left_at IS NULL
ORDER BY c.updated_at DESC
`

func (q *Queries) GetUserConversations(ctx context.Context, userID int64) ([]Conversation, error) {
	rows, err := q.db.Query(ctx, getUserConversations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserInConversation = `-- name: IsUserInConversation :one
SELECT EXISTS(
  SELECT 1 
  FROM conversation_participants 
  WHERE conversation_id = $1 AND user_id = $2 AND left_at IS NULL
) AS is_member
`

type IsUserInConversationParams struct {
	ConversationID int64 `json:"conversation_id"`
	UserID         int64 `json:"user_id"`
}

func (q *Queries) IsUserInConversation(ctx context.Context, arg IsUserInConversationParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInConversation, arg.ConversationID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const markMessageAsRead = `-- name: MarkMessageAsRead :one
INSERT INTO message_read_status (
  message_id,
  user_id
) VALUES (
  $1, $2
) ON CONFLICT DO NOTHING
RETURNING message_id, user_id, read_at
`

type MarkMessageAsReadParams struct {
	MessageID int64 `json:"message_id"`
	UserID    int64 `json:"user_id"`
}

func (q *Queries) MarkMessageAsRead(ctx context.Context, arg MarkMessageAsReadParams) (MessageReadStatus, error) {
	row := q.db.QueryRow(ctx, markMessageAsRead, arg.MessageID, arg.UserID)
	var i MessageReadStatus
	err := row.Scan(&i.MessageID, &i.UserID, &i.ReadAt)
	return i, err
}

const removeParticipantFromConversation = `-- name: RemoveParticipantFromConversation :exec
UPDATE conversation_participants
SET left_at = NOW()
WHERE conversation_id = $1 AND user_id = $2 AND left_at IS NULL
`

type RemoveParticipantFromConversationParams struct {
	ConversationID int64 `json:"conversation_id"`
	UserID         int64 `json:"user_id"`
}

func (q *Queries) RemoveParticipantFromConversation(ctx context.Context, arg RemoveParticipantFromConversationParams) error {
	_, err := q.db.Exec(ctx, removeParticipantFromConversation, arg.ConversationID, arg.UserID)
	return err
}

const updateConversationTimestamp = `-- name: UpdateConversationTimestamp :exec
UPDATE conversations
SET updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateConversationTimestamp(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateConversationTimestamp, id)
	return err
}
