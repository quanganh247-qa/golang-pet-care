// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: medicine.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMedicine = `-- name: CreateMedicine :one
INSERT INTO medicines (name, description, usage, dosage, frequency, duration, side_effects, expiration_date, quantity)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, description, usage, dosage, frequency, duration, side_effects, start_date, end_date, created_at, updated_at, expiration_date, quantity
`

type CreateMedicineParams struct {
	Name           string      `json:"name"`
	Description    pgtype.Text `json:"description"`
	Usage          pgtype.Text `json:"usage"`
	Dosage         pgtype.Text `json:"dosage"`
	Frequency      pgtype.Text `json:"frequency"`
	Duration       pgtype.Text `json:"duration"`
	SideEffects    pgtype.Text `json:"side_effects"`
	ExpirationDate pgtype.Date `json:"expiration_date"`
	Quantity       pgtype.Int8 `json:"quantity"`
}

func (q *Queries) CreateMedicine(ctx context.Context, arg CreateMedicineParams) (Medicine, error) {
	row := q.db.QueryRow(ctx, createMedicine,
		arg.Name,
		arg.Description,
		arg.Usage,
		arg.Dosage,
		arg.Frequency,
		arg.Duration,
		arg.SideEffects,
		arg.ExpirationDate,
		arg.Quantity,
	)
	var i Medicine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.SideEffects,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpirationDate,
		&i.Quantity,
	)
	return i, err
}

const getMedicineByID = `-- name: GetMedicineByID :one
SELECT id, name, description, usage, dosage, frequency, duration, side_effects, start_date, end_date, created_at, updated_at, expiration_date, quantity FROM medicines
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMedicineByID(ctx context.Context, id int64) (Medicine, error) {
	row := q.db.QueryRow(ctx, getMedicineByID, id)
	var i Medicine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.SideEffects,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpirationDate,
		&i.Quantity,
	)
	return i, err
}

const listMedicinesByPet = `-- name: ListMedicinesByPet :many
SELECT 
    m.usage AS medicine_usage,
    m.name AS medicine_name,
    m.description AS medicine_description,
    pm.dosage,
    pm.frequency,
    pm.duration,
    pm.notes AS medicine_notes,
    pt.start_date AS treatment_start_date,
    pt.end_date AS treatment_end_date,
    pt.status AS treatment_status
FROM 
    pet_treatments pt
JOIN 
    treatment_phases tp ON pt.disease_id = tp.disease_id
JOIN 
    phase_medicines pm ON tp.id = pm.phase_id
JOIN 
    medicines m ON pm.medicine_id = m.id
WHERE 
    pt.pet_id = $1 and pt.status = $2 -- Replace with the specific pet_id
ORDER BY 
    tp.start_date, pm.medicine_id LIMIT $3 OFFSET $4
`

type ListMedicinesByPetParams struct {
	PetID  pgtype.Int8 `json:"pet_id"`
	Status pgtype.Text `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListMedicinesByPetRow struct {
	MedicineUsage       pgtype.Text `json:"medicine_usage"`
	MedicineName        string      `json:"medicine_name"`
	MedicineDescription pgtype.Text `json:"medicine_description"`
	Dosage              pgtype.Text `json:"dosage"`
	Frequency           pgtype.Text `json:"frequency"`
	Duration            pgtype.Text `json:"duration"`
	MedicineNotes       pgtype.Text `json:"medicine_notes"`
	TreatmentStartDate  pgtype.Date `json:"treatment_start_date"`
	TreatmentEndDate    pgtype.Date `json:"treatment_end_date"`
	TreatmentStatus     pgtype.Text `json:"treatment_status"`
}

func (q *Queries) ListMedicinesByPet(ctx context.Context, arg ListMedicinesByPetParams) ([]ListMedicinesByPetRow, error) {
	rows, err := q.db.Query(ctx, listMedicinesByPet,
		arg.PetID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMedicinesByPetRow{}
	for rows.Next() {
		var i ListMedicinesByPetRow
		if err := rows.Scan(
			&i.MedicineUsage,
			&i.MedicineName,
			&i.MedicineDescription,
			&i.Dosage,
			&i.Frequency,
			&i.Duration,
			&i.MedicineNotes,
			&i.TreatmentStartDate,
			&i.TreatmentEndDate,
			&i.TreatmentStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
