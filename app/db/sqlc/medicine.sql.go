// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: medicine.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
const createMedicine = `-- name: CreateMedicine :one
INSERT INTO medicines (name, description, usage, dosage, frequency, duration, side_effects, expiration_date, quantity)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, description, usage, dosage, frequency, duration, side_effects, start_date, end_date, created_at, updated_at, expiration_date, quantity
`

type CreateMedicineParams struct {
	Name           string      `json:"name"`
	Description    pgtype.Text `json:"description"`
	Usage          pgtype.Text `json:"usage"`
	Dosage         pgtype.Text `json:"dosage"`
	Frequency      pgtype.Text `json:"frequency"`
	Duration       pgtype.Text `json:"duration"`
	SideEffects    pgtype.Text `json:"side_effects"`
	ExpirationDate pgtype.Date `json:"expiration_date"`
	Quantity       pgtype.Int8 `json:"quantity"`
}

func (q *Queries) CreateMedicine(ctx context.Context, arg CreateMedicineParams) (Medicine, error) {
	row := q.db.QueryRow(ctx, createMedicine,
		arg.Name,
		arg.Description,
		arg.Usage,
		arg.Dosage,
		arg.Frequency,
		arg.Duration,
		arg.SideEffects,
		arg.ExpirationDate,
		arg.Quantity,
	)
=======
const createAllergy = `-- name: CreateAllergy :one
INSERT INTO allergies (medical_record_id, allergen, severity, reaction, notes)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, medical_record_id, allergen, severity, reaction, notes, created_at, updated_at
`

type CreateAllergyParams struct {
	MedicalRecordID pgtype.Int8 `json:"medical_record_id"`
	Allergen        []byte      `json:"allergen"`
	Severity        pgtype.Text `json:"severity"`
	Reaction        []byte      `json:"reaction"`
	Notes           pgtype.Text `json:"notes"`
}

func (q *Queries) CreateAllergy(ctx context.Context, arg CreateAllergyParams) (Allergy, error) {
	row := q.db.QueryRow(ctx, createAllergy,
		arg.MedicalRecordID,
		arg.Allergen,
		arg.Severity,
		arg.Reaction,
		arg.Notes,
	)
	var i Allergy
	err := row.Scan(
		&i.ID,
		&i.MedicalRecordID,
		&i.Allergen,
		&i.Severity,
		&i.Reaction,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

=======
>>>>>>> 4ccd381 (Update appointment flow)
const createMedicine = `-- name: CreateMedicine :one
INSERT INTO medicines (name, description, usage, dosage, frequency, duration, side_effects, expiration_date, quantity)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, description, usage, dosage, frequency, duration, side_effects, start_date, end_date, created_at, updated_at, expiration_date, quantity
`

type CreateMedicineParams struct {
	Name           string      `json:"name"`
	Description    pgtype.Text `json:"description"`
	Usage          pgtype.Text `json:"usage"`
	Dosage         pgtype.Text `json:"dosage"`
	Frequency      pgtype.Text `json:"frequency"`
	Duration       pgtype.Text `json:"duration"`
	SideEffects    pgtype.Text `json:"side_effects"`
	ExpirationDate pgtype.Date `json:"expiration_date"`
	Quantity       pgtype.Int8 `json:"quantity"`
}

func (q *Queries) CreateMedicine(ctx context.Context, arg CreateMedicineParams) (Medicine, error) {
<<<<<<< HEAD
	row := q.db.QueryRow(ctx, createMedicine, arg.Name, arg.Description, arg.Usage)
>>>>>>> 3bf345d (happy new year)
=======
	row := q.db.QueryRow(ctx, createMedicine,
		arg.Name,
		arg.Description,
		arg.Usage,
		arg.Dosage,
		arg.Frequency,
		arg.Duration,
		arg.SideEffects,
		arg.ExpirationDate,
		arg.Quantity,
	)
>>>>>>> e859654 (Elastic search)
	var i Medicine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.SideEffects,
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
		&i.MedicalRecordID,
		&i.PrescribingVet,
>>>>>>> 3bf345d (happy new year)
		&i.StartDate,
		&i.EndDate,
=======
		&i.ExpirationDate,
		&i.Quantity,
>>>>>>> e859654 (Elastic search)
		&i.CreatedAt,
		&i.UpdatedAt,
<<<<<<< HEAD
		&i.ExpirationDate,
		&i.Quantity,
=======
>>>>>>> 3bf345d (happy new year)
=======
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpirationDate,
		&i.Quantity,
>>>>>>> ada3717 (Docker file)
	)
	return i, err
}

<<<<<<< HEAD
const getMedicineByID = `-- name: GetMedicineByID :one
SELECT id, name, description, usage, dosage, frequency, duration, side_effects, start_date, end_date, created_at, updated_at, expiration_date, quantity FROM medicines
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMedicineByID(ctx context.Context, id int64) (Medicine, error) {
	row := q.db.QueryRow(ctx, getMedicineByID, id)
	var i Medicine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.SideEffects,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpirationDate,
		&i.Quantity,
<<<<<<< HEAD
=======
const deleteAllergy = `-- name: DeleteAllergy :exec
DELETE FROM Allergies
WHERE id = $1
`

func (q *Queries) DeleteAllergy(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAllergy, id)
	return err
}

const getAllergies = `-- name: GetAllergies :many
SELECT id, medical_record_id, allergen, severity, reaction, notes, created_at, updated_at FROM allergies
WHERE medical_record_id = $1
`

func (q *Queries) GetAllergies(ctx context.Context, medicalRecordID pgtype.Int8) ([]Allergy, error) {
	rows, err := q.db.Query(ctx, getAllergies, medicalRecordID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Allergy{}
	for rows.Next() {
		var i Allergy
		if err := rows.Scan(
			&i.ID,
			&i.MedicalRecordID,
			&i.Allergen,
			&i.Severity,
			&i.Reaction,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
=======
	)
	return i, err
>>>>>>> 4ccd381 (Update appointment flow)
}

const getMedicineByID = `-- name: GetMedicineByID :one
SELECT id, name, description, usage, dosage, frequency, duration, side_effects, start_date, end_date, created_at, updated_at, expiration_date, quantity FROM medicines
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMedicineByID(ctx context.Context, id int64) (Medicine, error) {
	row := q.db.QueryRow(ctx, getMedicineByID, id)
	var i Medicine
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Usage,
		&i.Dosage,
		&i.Frequency,
		&i.Duration,
		&i.SideEffects,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
<<<<<<< HEAD
>>>>>>> 3bf345d (happy new year)
=======
		&i.ExpirationDate,
		&i.Quantity,
>>>>>>> ada3717 (Docker file)
	)
	return i, err
}

const listMedicinesByPet = `-- name: ListMedicinesByPet :many
SELECT 
    m.usage AS medicine_usage,
<<<<<<< HEAD
=======
const listMedicinesByPet = `-- name: ListMedicinesByPet :many
SELECT 
>>>>>>> a415f25 (new data)
=======
>>>>>>> 2a87fca (medicine id and usage in treatment)
=======
const listMedicinesByPet = `-- name: ListMedicinesByPet :many
SELECT 
>>>>>>> a415f25 (new data)
    m.name AS medicine_name,
    m.description AS medicine_description,
    pm.dosage,
    pm.frequency,
    pm.duration,
    pm.notes AS medicine_notes,
    pt.start_date AS treatment_start_date,
    pt.end_date AS treatment_end_date,
    pt.status AS treatment_status
FROM 
    pet_treatments pt
JOIN 
    treatment_phases tp ON pt.disease_id = tp.disease_id
JOIN 
    phase_medicines pm ON tp.id = pm.phase_id
JOIN 
    medicines m ON pm.medicine_id = m.id
WHERE 
    pt.pet_id = $1 and pt.status = $2 -- Replace with the specific pet_id
ORDER BY 
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
    tp.start_date, pm.medicine_id LIMIT $3 OFFSET $4
=======
    tp.phase_number, pm.medicine_id LIMIT $3 OFFSET $4
>>>>>>> a415f25 (new data)
=======
    tp.start_date, pm.medicine_id LIMIT $3 OFFSET $4
>>>>>>> 3bf345d (happy new year)
=======
    tp.phase_number, pm.medicine_id LIMIT $3 OFFSET $4
>>>>>>> a415f25 (new data)
`

type ListMedicinesByPetParams struct {
	PetID  pgtype.Int8 `json:"pet_id"`
	Status pgtype.Text `json:"status"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListMedicinesByPetRow struct {
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
	MedicineUsage       pgtype.Text `json:"medicine_usage"`
=======
>>>>>>> a415f25 (new data)
=======
	MedicineUsage       pgtype.Text `json:"medicine_usage"`
>>>>>>> 2a87fca (medicine id and usage in treatment)
=======
>>>>>>> a415f25 (new data)
	MedicineName        string      `json:"medicine_name"`
	MedicineDescription pgtype.Text `json:"medicine_description"`
	Dosage              pgtype.Text `json:"dosage"`
	Frequency           pgtype.Text `json:"frequency"`
	Duration            pgtype.Text `json:"duration"`
	MedicineNotes       pgtype.Text `json:"medicine_notes"`
	TreatmentStartDate  pgtype.Date `json:"treatment_start_date"`
	TreatmentEndDate    pgtype.Date `json:"treatment_end_date"`
	TreatmentStatus     pgtype.Text `json:"treatment_status"`
}

func (q *Queries) ListMedicinesByPet(ctx context.Context, arg ListMedicinesByPetParams) ([]ListMedicinesByPetRow, error) {
	rows, err := q.db.Query(ctx, listMedicinesByPet,
		arg.PetID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMedicinesByPetRow{}
	for rows.Next() {
		var i ListMedicinesByPetRow
		if err := rows.Scan(
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
			&i.MedicineUsage,
=======
>>>>>>> a415f25 (new data)
=======
			&i.MedicineUsage,
>>>>>>> 2a87fca (medicine id and usage in treatment)
=======
>>>>>>> a415f25 (new data)
			&i.MedicineName,
			&i.MedicineDescription,
			&i.Dosage,
			&i.Frequency,
			&i.Duration,
			&i.MedicineNotes,
			&i.TreatmentStartDate,
			&i.TreatmentEndDate,
			&i.TreatmentStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
